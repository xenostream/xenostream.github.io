<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>SED Web Editor + VFS Shell (Integrated)</title>
<style>
:root { --console-h: 220px; }
html, body {
  margin: 0; padding: 0;
  height: 100%; width: 100%;
  overflow: hidden;
  font-family: "Cascadia Mono", monospace;
  background: #1e1e1e;
}
#editor { height: calc(100vh - var(--console-h)); width: 100vw; transition: height 0.2s ease; }
#console {
  height: var(--console-h); width: 100vw;
  background: #111; color: #0f0;
  display: flex; flex-direction: column;
  border-top: 1px solid #333;
  overflow: hidden; transition: height 0.2s ease;
}
#console-header {
  background: #222; padding: 4px 8px; font-size: 12px;
  user-select: none; display: flex; align-items: center; gap: 8px;
  cursor: pointer;
}
#toggle-btn { font-weight: 600; }
.hint { color: #999; margin-left: auto; font-size: 11px; }
#console-resizer {
  height: 5px;
  cursor: ns-resize;
  background: #333;
}
#console-output {
  flex: 1; padding: 6px; overflow-y: auto; font-size: 13px; white-space: pre-wrap;
  border-top: 1px solid #333; border-bottom: 1px solid #333; background: #111; color: #0f0;
}
#console-input { height: 90px; }
#console-output::-webkit-scrollbar { width: 8px; }
#console-output::-webkit-scrollbar-track { background: #111; }
#console-output::-webkit-scrollbar-thumb { background-color: #222; border-radius: 4px; }
#console-output::-webkit-scrollbar-thumb:hover { background-color: #333; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

<!-- Aioli -->
<script>
var defineBackup = window.define;
window.define = undefined;
</script>
<script src="https://biowasm.com/cdn/v3/aioli/latest/aioli.js"></script>
<script>
window.define = defineBackup;
</script>
</head>
<body>
<div id="editor"></div>
<div id="console">
  <div id="console-header">
    <span id="toggle-btn">â–¼ Console</span>
    <span class="hint">ğŸ–¥ï¸ë¯¸ë‹ˆì‰˜ ì „ì²´ ê¸°ëŠ¥ â€¢ â¬†ï¸â¬‡ï¸ëª…ë ¹ íˆìŠ¤í† ë¦¬ â€¢ ğŸ”„Tab ëª…ë ¹ ìë™ì™„ì„± â€¢ ì²˜ë¦¬ ëŒ€ìƒì´ input.txt ë©´ ì—ë””í„° ë°˜ì˜</span>
  </div>
  <div id="console-resizer"></div>
  <div id="console-output"></div>
  <div id="console-input"></div>
</div>

<script>
require.config({ paths: { vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs" } });

let editor, jsConsole;
let currentFileName = "input.txt";
let CLI = null;
let currentDir = "/shared/data";
let history = [];
let historyIndex = -1;
let lastHeight = "220px";

const commands = [
  "pwd","cd","mkdir","rm","ls","cat","tree",
  "echo","head","tail","sort","uniq","wc","md5sum","tr",
  "sed","gawk","grep","jq","clear","get"
];

const HELP_TEXT = `
ğŸ“‚ íŒŒì¼ & ë””ë ‰í† ë¦¬ ê´€ë¦¬
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- ls                  : ë””ë ‰í† ë¦¬ ëª©ë¡ ì¶œë ¥
- tree dir            : ë””ë ‰í† ë¦¬ êµ¬ì¡° ì¶œë ¥
- pwd                 : í˜„ì¬ ê²½ë¡œ ì¶œë ¥
- cd dir              : ë””ë ‰í† ë¦¬ ë³€ê²½
- mkdir dir           : ë””ë ‰í† ë¦¬ ìƒì„±
- rm file             : íŒŒì¼ ì‚­ì œ
- get file            : VFSì— ìˆëŠ” íŒŒì¼ì„ ë¡œì»¬ë¡œ ë‹¤ìš´ë¡œë“œ

ğŸ“‘ íŒŒì¼ ë‚´ìš© ë³´ê¸° & ì¶œë ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- cat file.txt        : íŒŒì¼ ë‚´ìš© ì¶œë ¥
- head -n 10 file     : íŒŒì¼ ì•ë¶€ë¶„ ì¶œë ¥
- tail -n 10 file     : íŒŒì¼ ëë¶€ë¶„ ì¶œë ¥
- echo Hello          : ë¬¸ìì—´ ì¶œë ¥
- clear               : ì½˜ì†” ì¶œë ¥ ì´ˆê¸°í™”

ğŸ” ê²€ìƒ‰ & í…ìŠ¤íŠ¸ ì²˜ë¦¬
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- grep 'pattern' file : ë¬¸ìì—´ ê²€ìƒ‰
- sort file           : ì •ë ¬
- uniq file           : ì—°ì† ì¤‘ë³µ ì œê±°
- wc -l file          : ë‹¨ì–´/ë¼ì¸ ìˆ˜ ê³„ì‚°
- tr a-z A-Z          : ë¬¸ì ì¹˜í™˜
- sed 's/old/new/' file : í…ìŠ¤íŠ¸ ë³€í™˜
- gawk '{print $1}' file : í…ìŠ¤íŠ¸ ì²˜ë¦¬

ğŸ“Š ë°ì´í„° & í¬ë§· ì²˜ë¦¬
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- jq '.key' file.json : JSON ì²˜ë¦¬
- md5sum file         : MD5 í•´ì‹œ ìƒì„±

ğŸ•’ ì‹œìŠ¤í…œ ì •ë³´
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- date                : í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ í‘œì‹œ

ğŸ“ íŠ¹ê¸°ì‚¬í•­
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- ì—ë””í„°ëŠ” í•­ìƒ input.txtì™€ ì—°ê²°ë©ë‹ˆë‹¤.
- sed ... input.txt ì‹¤í–‰ ì‹œ ê²°ê³¼ê°€ stdoutì´ë©´ ì—ë””í„°ì— ë°˜ì˜ë©ë‹ˆë‹¤.
- sed -i ë˜ëŠ” 'w file'ì„ í¬í•¨í•˜ë©´ VFS íŒŒì¼ë§Œ ìˆ˜ì •ë˜ê³ ,
  ì—ë””í„°ëŠ” VFSì—ì„œ ë‹¤ì‹œ ì½ì–´ì˜µë‹ˆë‹¤.
`;

function log(msg) {
  const out = document.getElementById("console-output");
  out.textContent += msg + "\n";
  out.scrollTop = out.scrollHeight;
}

function tokenize(str) {
  const re = /'([^']*)'|"([^"]*)"|(\S+)/g;
  const tokens = [];
  let match;
  while ((match = re.exec(str)) !== null) {
    if (match[1] !== undefined) tokens.push(match[1]);
    else if (match[2] !== undefined) tokens.push(match[2]);
    else tokens.push(match[3]);
  }
  return tokens;
}

// --- Monaco language detection by extension ---
function extToLanguage(name) {
  const ext = (name.split(".").pop() || "").toLowerCase();
  const map = {
    "txt": "plaintext",
    "md": "markdown",
    "js": "javascript",
    "ts": "typescript",
    "json": "json",
    "py": "python",
    "sh": "shell",
    "bash": "shell",
    "html": "html",
    "htm": "html",
    "css": "css",
    "c": "c",
    "h": "c",
    "cpp": "cpp",
    "hpp": "cpp",
    "java": "java",
    "go": "go",
    "rs": "rust",
    "xml": "xml",
    "yml": "yaml",
    "yaml": "yaml",
    "sql": "sql",
    "csv": "plaintext",
    "log": "plaintext"
  };
  return map[ext] || "plaintext";
}
function applyEditorLanguageByFileName(name) {
  if (!editor) return;
  const lang = extToLanguage(name);
  const model = editor.getModel();
  if (model) monaco.editor.setModelLanguage(model, lang);
}

// --- Sync helpers ---
async function syncEditorToVFS() {
  if (!CLI) return;
  const text = editor.getValue();
  await CLI.fs.writeFile(`${currentDir}/${currentFileName}`, new TextEncoder().encode(text));
}
async function syncVFSToEditor() {
  if (!CLI) return;
  try {
    const data = await CLI.fs.readFile(`${currentDir}/${currentFileName}`);
    const decoded = new TextDecoder().decode(data);
    const model = editor.getModel();
    const fullRange = model.getFullModelRange();
    editor.executeEdits("vfs->editor", [{ range: fullRange, text: decoded }]);
  } catch (e) {
    await syncEditorToVFS();
  }
}

async function safeMkdir(path) { try { await CLI.mkdir(path); } catch {} }

async function initShell() {
  try {
    const start = Date.now();
    while (typeof window.Aioli === "undefined") {
      if (Date.now() - start > 5000) { log("Aioli ë¡œë“œ ì‹¤íŒ¨"); return; }
      await new Promise(r => setTimeout(r, 50));
    }

    const coreutils = ["ls","cat","echo","head","tail","sort","uniq","wc","md5sum","tr", "date"];
    const others = [
      { tool: "sed",  version: "4.8",  program: "sed"  },
      { tool: "tree", version: "2.0.4", program: "tree" },
      { tool: "gawk", version: "5.1.0", program: "gawk" },
      { tool: "grep", version: "3.7",  program: "grep" },
      { tool: "jq",   version: "1.7",  program: "jq"   }
    ];

    CLI = await new Aioli([
      "base/1.0.0",
      ...coreutils.map(p => ({ tool:"coreutils", version:"8.32", program:p, loading:"lazy", reinit:true })),
      ...others.map(t => ({ ...t, loading:"lazy", reinit:true }))
    ], { printInterleaved:false, debug:false });

    await safeMkdir("/shared");
    await safeMkdir("/shared/data");
    await CLI.cd("/shared/data");
    currentDir = (await CLI.pwd()).toString().trim();

    await CLI.fs.writeFile(`${currentDir}/help.txt`, new TextEncoder().encode(HELP_TEXT.trim()));
    await CLI.fs.writeFile(`${currentDir}/${currentFileName}`, new TextEncoder().encode(`foo bar
foo baz
í•˜ë‚˜ ë‘˜ ì…‹
hello world`));
    await syncVFSToEditor();
    applyEditorLanguageByFileName(currentFileName);

    log(`VFS ì›¹ ì‰˜ ì¤€ë¹„ ì™„ë£Œ âœ… (${currentDir}/help.txt, ${currentFileName} ì¤€ë¹„ë¨)`);
  } catch (e) {
    log("ì´ˆê¸°í™” ì‹¤íŒ¨: " + e.message);
  }
}
window.addEventListener("load", initShell);

function logResult(result){
  if(result==null) return;
  if(typeof result === "string"){
    if(result.trim()) log(result.trim());
  }else{
    if(result.stdout && result.stdout.trim()) log(result.stdout.trim());
  }
}

function sedHasWrite(args) {
  const hasInPlace = args.some(a => a.startsWith("-i"));
  const script = args.find(a => typeof a === "string" && a.includes("w "));
  return hasInPlace || !!script;
}

const handlers = {
  // Console
  clear: async () => { document.getElementById("console-output").textContent = ""; },

  // FS navigation
  cd: async (args) => {
    const path = args[0] || "/";
    await CLI.cd(path);
    const pwd = await CLI.pwd();
    currentDir = pwd.toString().trim();
    log(`í˜„ì¬ ë””ë ‰í† ë¦¬: ${currentDir}`);
  },
  pwd: async () => {
    const pwd = await CLI.pwd();
    currentDir = pwd.toString().trim();
    log(currentDir);
  },
  mkdir: async (args) => {
    if (args[0]) { await CLI.mkdir(args[0]); log(`ë””ë ‰í† ë¦¬ ìƒì„± ì™„ë£Œ: ${args[0]}`); }
  },
  rm: async (args) => {
    if (args[0]) { await CLI.fs.unlink(args[0]); log(`ì‚­ì œ ì™„ë£Œ: ${args[0]}`); }
  },

  // Content/view commands
  ls: async (args) => { const r = await CLI.exec("ls", args); logResult(r); },
  cat: async (args) => { const r = await CLI.exec("cat", args); logResult(r); },
  echo: async (args) => { const r = await CLI.exec("echo", args); logResult(r); },
  head: async (args) => { const r = await CLI.exec("head", args); logResult(r); },
  tail: async (args) => { const r = await CLI.exec("tail", args); logResult(r); },
  sort: async (args) => { const r = await CLI.exec("sort", args); logResult(r); },
  uniq: async (args) => { const r = await CLI.exec("uniq", args); logResult(r); },
  wc: async (args) => { const r = await CLI.exec("wc", args); logResult(r); },
  md5sum: async (args) => { const r = await CLI.exec("md5sum", args); logResult(r); },
  tr: async (args) => { const r = await CLI.exec("tr", args); logResult(r); },
  tree: async (args) => { const r = await CLI.exec("tree", args.length ? args : ["."]); logResult(r); },
  gawk: async (args) => { const r = await CLI.exec("gawk", args); logResult(r); },
  grep: async (args) => { const r = await CLI.exec("grep", args); logResult(r); },
  jq: async (args) => { const r = await CLI.exec("jq", args); logResult(r); },

  // sed special handling with editor sync when target is input.txt
  sed: async (args) => {
    const target = args[args.length - 1];
    const hasWrite = sedHasWrite(args);

    if (target === currentFileName) {
      await syncEditorToVFS();
    }

    const result = await CLI.exec("sed", args);

    if (target === currentFileName) {
      if (!hasWrite && result && typeof result.stdout === "string") {
        const model = editor.getModel();
        const fullRange = model.getFullModelRange();
        editor.executeEdits("sed-replace", [{ range: fullRange, text: result.stdout }]);
        await syncEditorToVFS();
      } else if (hasWrite) {
        await syncVFSToEditor();
      }
    }

    logResult(result);
    log(`ì‹¤í–‰ë¨: sed ${args.join(" ")}`);
  },

  // Download
  get: async (args) => {
    if (!args[0]) { log("ì‚¬ìš©ë²•: get <íŒŒì¼ëª…>"); return; }
    const fname = args[0];
    try {
      if (fname === currentFileName) {
        const blob = new Blob([editor.getValue()], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = currentFileName; a.click();
        URL.revokeObjectURL(url);
        log(`â¬‡ï¸ ${currentFileName} ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
        return;
      }
      const data = await CLI.fs.readFile(`${currentDir}/${fname}`);
      const blob = new Blob([data]);
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = fname; a.click();
      URL.revokeObjectURL(url);
      log(`â¬‡ï¸ ${fname} ë‹¤ìš´ë¡œë“œ ì™„ë£Œ`);
    } catch(err){
      log("ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: " + err.message);
    }
  }
};

async function runCmd(cmd) {
  if (!CLI) { log("ì‰˜ ì¤€ë¹„ ì¤‘..."); return; }
  try {
    log(`$ ${cmd}`);
    const args = tokenize(cmd);
    if (args.length === 0) return;
    const prog = args[0];
    const progArgs = args.slice(1);

    if (handlers[prog]) {
      await handlers[prog](progArgs);
      return;
    }
    const result = await CLI.exec(prog, progArgs);
    logResult(result);
  } catch (e) {
    log("Error: " + e.message);
  }
}

// Monaco setup
require(["vs/editor/editor.main"], function() {
  editor = monaco.editor.create(document.getElementById("editor"), {
    value: "",
    language: "plaintext",
    theme: "vs-dark",
    fontFamily: "Cascadia Mono, monospace",
    fontSize: 14,
    wordWrap: "on",
    folding: true,
    minimap: { enabled: true, side: "right" },
    lineNumbers: "on",
    cursorBlinking: "smooth",
    automaticLayout: true,
  });

  jsConsole = monaco.editor.create(document.getElementById("console-input"), {
    value: "sed '$r help.txt' input.txt",
    language: "shell",
    theme: "vs-dark",
    fontSize: 13,
    minimap: { enabled: false },
    lineNumbers: "off",
    wordWrap: "on",
    automaticLayout: true,
  });

  const ro = new ResizeObserver(() => editor.layout());
  ro.observe(document.getElementById("editor"));

  jsConsole.onKeyDown(async e => {
    if (e.keyCode === monaco.KeyCode.Enter) {
      if (e.shiftKey) return;
      e.preventDefault();
      const code = jsConsole.getValue().trim();
      if (code) {
        history.push(code);
        historyIndex = history.length;
        jsConsole.setValue("");
        await runCmd(code);
      } else {
        jsConsole.setValue("");
      }
    }
    else if (e.keyCode === monaco.KeyCode.UpArrow) {
      e.preventDefault();
      if (historyIndex > 0) {
        historyIndex--;
        jsConsole.setValue(history[historyIndex] || "");
      }
    }
    else if (e.keyCode === monaco.KeyCode.DownArrow) {
      e.preventDefault();
      if (historyIndex < history.length - 1) {
        historyIndex++;
        jsConsole.setValue(history[historyIndex] || "");
      } else {
        historyIndex = history.length;
        jsConsole.setValue("");
      }
    }
    else if (e.keyCode === monaco.KeyCode.Tab) {
      e.preventDefault();
      const val = jsConsole.getValue().trim();
      if (!val) return;
      const tokens = tokenize(val);
      const firstToken = tokens[0] || "";
      const matches = commands.filter(c => c.startsWith(firstToken));
      if (matches.length === 1) {
        tokens[0] = matches[0];
        jsConsole.setValue(tokens.join(" ") + " ");
      } else if (matches.length > 1) {
        log("ê°€ëŠ¥í•œ ëª…ë ¹: " + matches.join(" "));
      }
    }
  });

  // ì—ë””í„° ì´ˆê¸° ë‚´ìš©ì€ VFSì—ì„œ ë¡œë“œë¨
});

// beforeunload
window.addEventListener("beforeunload", function(e){ e.preventDefault(); e.returnValue = ""; });

// Console toggle + resizer (ì ‘ìœ¼ë©´ 25px ê³ ì •, í¼ì¹˜ë©´ ë§ˆì§€ë§‰ ë†’ì´ ë³µì›, ë“œë˜ê·¸ë¡œ ë†’ì´ ì¡°ì ˆ)
const rootStyle=document.documentElement.style;
const toggleBtn=document.getElementById("toggle-btn");
const header=document.getElementById("console-header");
const resizer=document.getElementById("console-resizer");
function setConsoleHeight(px){ rootStyle.setProperty("--console-h",px); requestAnimationFrame(()=>editor&&editor.layout()); }
header.addEventListener("click",()=>{
  const collapsed=toggleBtn.textContent.startsWith("â–¼")?false:true;
  if(!collapsed){
    lastHeight=getComputedStyle(document.documentElement).getPropertyValue("--console-h");
    setConsoleHeight("25px");
    toggleBtn.textContent="â–¶ Console";
  } else {
    setConsoleHeight(lastHeight);
    toggleBtn.textContent="â–¼ Console";
  }
});
let isResizing=false;
resizer.addEventListener("mousedown",()=>{ isResizing=true; document.body.style.userSelect="none"; });
window.addEventListener("mousemove",e=>{
  if(!isResizing) return;
  const newHeight=window.innerHeight-e.clientY;
  if(newHeight>25 && newHeight<window.innerHeight-50){
    const h = newHeight+"px";
    setConsoleHeight(h);
    lastHeight = h;
  }
});
window.addEventListener("mouseup",()=>{ isResizing=false; document.body.style.userSelect=""; });

// Drag & Drop + Ctrl+O file open (ì–¸ì–´ ìë™ ë³€ê²½ í¬í•¨)
const editorDiv=document.getElementById("editor");
editorDiv.addEventListener("dragover", e=>e.preventDefault());
editorDiv.addEventListener("drop", async e=>{
  e.preventDefault();
  const file=e.dataTransfer.files[0];
  if(file){
    const text=await file.text();
    editor.setValue(text);
    currentFileName=file.name;
    applyEditorLanguageByFileName(currentFileName);
    await syncEditorToVFS();
    log(`ë“œë˜ê·¸ë¡œ ${file.name} ë¶ˆëŸ¬ì˜´`);
  }
});
window.addEventListener("keydown", async e=>{
  if(e.ctrlKey && e.key.toLowerCase()==="o"){
    e.preventDefault();
    const input=document.createElement("input");
    input.type="file";
    input.onchange=async ev=>{
      const file=ev.target.files[0];
      if(file){
        const text=await file.text();
        editor.setValue(text);
        currentFileName=file.name;
        applyEditorLanguageByFileName(currentFileName);
        await syncEditorToVFS();
        log(`Ctrl+Oë¡œ ${file.name} ë¶ˆëŸ¬ì˜´`);
      }
    };
    input.click();
  }
});
</script>
</body>
</html>
