<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Go Web Programming: [02/02] Go Foundation &middot;  XenoStream&#39;s Private Site" />
  
  <meta property="og:site_name" content="XenoStream&#39;s Private Site" />
  <meta property="og:url" content="http://xenostream.github.io/2016/02/go-web-programming-02/02-go-foundation" />
  
  
  <meta property="og:type" content="article" />
  
  <meta property="og:article:published_time" content="2016-02-17T00:00:00Z" />
  
  <meta property="og:article:tag" content="goweb" />
  
  

  <title>
     Go Web Programming: [02/02] Go Foundation &middot;  XenoStream&#39;s Private Site
  </title>

  <link rel="stylesheet" href="http://xenostream.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="http://xenostream.github.io/css/main.css" />
  <link rel="stylesheet" href="http://xenostream.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="http://xenostream.github.io/css/github.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400" type="text/css">
  <link rel="shortcut icon" href="http://xenostream.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="http://xenostream.github.io/images/apple-touch-icon.png" />
  
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="http://xenostream.github.io/">XenoStream&#39;s Private Site</a></h1>
      
      <div class="tag-line">
        Software &amp; System Engineer!!
      </div>
      
      <div class="sns-links hidden-print">
  
  <a href="http://xenostream.github.io/2016/02/about">
	  <i class="fa fa-user-md fa-fw"></i>
  </a>
  
  
  <a href="http://xenostream.github.io/tags">
	  <i class="fa fa-tags"></i>
  </a>
  
  
  <a href="http://xenostream.github.io/post">
      <i class="fa fa-archive fa-fw"></i>
  </a>
  
  
  
  
  
  
  
  
  
</div>

      
      <a href="http://xenostream.github.io/" class="btn-header btn-back hidden-xs">
        <i class="fa fa-home" aria-hidden="true"></i>
        &nbsp;Home
      </a>
      
      
    </section>
  </header>
  <main class="container">



<article>
  <header>
    <h1 class="text-primary">Go Web Programming: [02/02] Go Foundation</h1>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2016-02-17T00:00:00Z">
          Feb 17, 2016
        </time>
      </div>
      <div class="pull-right">
        
        <span class="post-tag small"><a href="http://xenostream.github.io//tags/goweb">#goweb</a></span>
        
      </div>
    </div>
  </header>
  <section>
    

<h1 id="go-foundation:2ef2f3fc9ee3102fd2ffea6f9cac38b4">Go Foundation</h1>

<p>이 장에서는 변수, 상수, 기본타입과 Go 프로그램의 여러가지 기본적인 기법에 대해서 소개 합니다.</p>

<h2 id="변수:2ef2f3fc9ee3102fd2ffea6f9cac38b4">변수</h2>

<p>Go 언어에서 변수는 여러가지 방법으로 선언될 수 있습니다. 가장 표준적인 방법인</p>

<blockquote>
<p><code>var</code> 키워드를 사용하여 변수를 선언하는 방법 입니다.</p>
</blockquote>

<p><code>C 언어</code>와 달리 Go언어는</p>

<blockquote>
<p>변수의 유형을 <strong>변수 뒤</strong>에 놓습니다!!!</p>
</blockquote>

<pre><code class="language-go">  // &quot;variableName&quot;라는 이름의 변수를 선언 합니다. 변수 형식은 &quot;type&quot;입니다.   
  var variableName type  
</code></pre>

<p>여러 변수를 한번에 선언 합니다.</p>

<pre><code class="language-go">  // &quot;type&quot;형의 변수 3개를 선언 합니다.
  var vname1, vname2, vname3 type
</code></pre>

<p>변수를 선언함과 동시에 초기화 합니다.</p>

<pre><code class="language-go">  // &quot;variableName&quot;변수를 &quot;value&quot;로 초기화합니다. 형식은 &quot;type&quot;입니다.
  var variableName type = value
</code></pre>

<p>여러개의 변수를 동시에 선언한 후 초기화 합니다.</p>

<pre><code class="language-go">/*
  모든 변수를 &quot;type&quot;형으로 선언하고,vname1은 v1, vname2는 v2, vname3은 v3으로 초기화 합니다. 
*/
  var vname1, vname2, vname3 type = v1, v2, v3
</code></pre>

<p>만약 위와 같은 방식으로 변수를 선언하는 방식이 불편하다고 생각 하십니까?<br />
이런 문제점은, Go 언어의 설계자도 이미 알고 있습니다. 좀 더 쉽게 변수를 선언할 수 있는 방법이 있습니다.<br />
초기값으로 해당변수의 형식을 판가름 할 수 있으므로, 다음과 같은 방법으로 변수를 선언할 수 있습니다.</p>

<pre><code class="language-go">/*
   3 개의 변수를 선언하고 개별적으로 초기화 합니다. 
   vname1는 v1, vname2는 v2, vname3는 v3 과 같이 대입되는 값의 형식에 맞게 각각의   
   형(타입)이 정해지고 초기화 됩니다.
*/
   var vname1, vname2, vname3 = v1, v2, v3
</code></pre>

<p>이런 방법도 여전히 번거로우신가요?<br />
좀 더 나은 방법으로 선언해 보겠습니다.</p>

<pre><code class="language-go">/*
  3개의 변수를 선언하고 개별적으로 초기화 합니다.
  vname1는 v1, vname2는 v2, vname3는 v3
  컴파일러는 초기화 값에 따라 자동으로 적합한 형식을 판단 합니다.   
*/
  vname1, vname2, vname3 :=  v1, v2, v3
</code></pre>

<p>이 방법이면 매우 간결하게 사용 할 수 있겠습니다.</p>

<blockquote>
<p><code>:=</code>기호가 <code>var</code>와<code>type</code>을 대체 합니다.</p>
</blockquote>

<p>이러한 형식으로 변수를 선언하는 것을 <code>단축선언</code>이라고 합니다. 그러나 이 단축선언 방식에는 한가지 제한이<br />
있습니다. 바로 <code>함수 내부</code>에서만 사용할 수 있습니다. 만약 함수 밖에서 사용하면 컴파일러가 에러를 출력 합니다.<br />
이말은 곧 일반적으로 <code>var</code> 형식으로 선언하는 변수들은 <code>글로벌 변수</code>로 선언된다는 의미 입니다.</p>

<p><code>_</code> (밑줄)은 변수의 <strong>특별한</strong> 이름 입니다. 어떤 값으로 초기화를 해도 그 값을 모두 버려 버립니다.<br />
다음의 경우, <code>35</code>라는 값을 <code>b</code>에 부여하며, <code>34</code>는 <strong>버려</strong> 버립니다.</p>

<pre><code class="language-go">_ , b := 34, 35
</code></pre>

<p>Go 컴파일러에서는,</p>

<blockquote>
<p><strong>선언한 후 사용하지 않는 변수가 발견되면
컴파일 오류</strong>를 출력 합니다.</p>
</blockquote>

<p>즉, 다음과 같은 코드는 에러 입니다. 그래서 <code>밑줄 변수</code>가 존재하는 것입니다.</p>

<pre><code class="language-go">package main

func main () {
    var i int
}
</code></pre>

<h2 id="상수:2ef2f3fc9ee3102fd2ffea6f9cac38b4">상수</h2>

<p>이른바 <code>상수</code>는 프로그램이 <code>컴파일되는 단계</code>에서 값이 결정되며, 프로그램이 실행되면 값을 절대 변경할 수<br />
없습니다. 이와같은 상수는 <code>숫자, bool 또는 문자열</code>등의 값을 사용해서 선언 할 수 있습니다.</p>

<p>상수로 선언하는 문법은 다음과 같습니다.</p>

<pre><code class="language-go">const constantName = value
    // 만약 필요하다면 상수의 타입을 명시적으로 표시 할 수 있습니다.  
const Pi float32 = 3.1415926
</code></pre>

<p>다음은 여러가지 상수 선언의 예제 입니다.</p>

<pre><code class="language-go">const Pi = 3.1415926
const i = 10000
const MaxThread = 10
const prefix = &quot;astaxie_&quot;
</code></pre>

<p>Go 상수는 일반적인 프로그래밍 언어와 달리 더욱 정밀한 소수점을 지정할 수 있습니다.(예: 소수점 200 자리 등)</p>

<h2 id="내장-기본형:2ef2f3fc9ee3102fd2ffea6f9cac38b4">내장 기본형</h2>

<h3 id="boolean:2ef2f3fc9ee3102fd2ffea6f9cac38b4">Boolean</h3>

<p>Go언어에서 bool값의 선언 키워드는 <code>bool</code>입니다. 값은<code>true</code> 혹은<code>false</code>이며, 기본값은 <code>false</code> 입니다.</p>

<pre><code class="language-go">var isActive bool                    // 전역 변수 선언
var enabled, disabled = true, false  // 형 생략 선언
func test () {
    var available bool               // 일반 선언
    valid := false                   // 단축 선언
    available = true                 // 대입 
}
</code></pre>

<h3 id="숫자:2ef2f3fc9ee3102fd2ffea6f9cac38b4">숫자</h3>

<p><code>정수</code>에는 부호와 무부호의 2가지가 있습니다. Go에서는 <code>int</code>와 <code>uint</code>로 지원하고 있습니다.<br />
이 두 타입은 길이는 비록 같지만, 32/64비트 운영체제에 따라 실제 길이는 다르게 표현 됩니다.</p>

<p>Go에서는 다음과 같이 직접 bit 수를 지정할 수있는 유형도 있습니다.</p>

<pre><code class="language-go">rune int8 int16 int32 int64 byte uint8 uint16 uint32 uint64
</code></pre>

<p><code>rune</code>은 <code>int32</code>의 별칭이며, UTF-8 한 문자를 저장 합니다.<br />
<code>byte</code>는 <code>uint8</code>의 별칭이며, ASCII한 문자를 저장 합니다.</p>

<p>주의해야 할 점은 한번 형태를 지정하면,</p>

<blockquote>
<p>다른 형식의 변수끼리 연산을 할 수 없으며,
연산시에는 오류를 발생 시킵니다.</p>
</blockquote>

<p>즉 다음의 코드는 오류가 발생합니다.</p>

<pre><code class="language-go"> var a int8
 var b int32
 c := a + b
</code></pre>

<p><code>invalid operation : a + b (mismatched types int8 and int32)</code></p>

<p>32비트 운영체제에서 int의 길이는 32bit지만, int 및 int32도 서로 연산할 수 없습니다.(강타입 언어)</p>

<p><code>부동 소수점</code> 형식은 <code>float32</code>와 <code>float64</code>의 두 종류만 있습니다 (<code>float</code> 형은 없습니다.)<br />
디폴트는 <code>float64</code> 입니다.</p>

<p>이것이 숫자의 모든것은 아닙니다. 공학도들에게 친숙한 복소수 또한 Go에서는 지원하고 있습니다.<br />
기본 형식은 <code>complex128</code>(64bit 실수 + 64bit 허수)입니다. 만약 좀 더 작은 값이 필요하다면,<br />
<code>complex64</code>(32bit 실수 + 32bit 허수)도 있습니다.<br />
복소수의 형식은 <code>RE + IMi</code> 입니다. 이 중 <code>RE</code>가 실수 부분 <code>IM</code>이  허수 부분이며,<br />
마지막<code>i</code>는 허수 단위 입니다. 다음은 복소수 사용 예제 입니다.</p>

<pre><code class="language-go">var c complex64 = 5 + 5i
fmt.Printf(&quot;Value is : % v&quot;, c)
</code></pre>

<p><code>Value is : (5 + 5i)</code> 와 같이 출력 됩니다.</p>

<h3 id="문자열:2ef2f3fc9ee3102fd2ffea6f9cac38b4">문자열</h3>

<p>앞 장에서 언급 한 바와 같이 Go언어에서 문자열은 모두 <code>UTF-8</code> 코드로 사용 합니다.<br />
문자열은 쌍 따옴표(&ldquo;&rdquo;) 또는 백틱(&ldquo;)으로 감싸는 것으로 선언 됩니다. (&ldquo;string&rdquo;)</p>

<pre><code class="language-go">var frenchHello string      // 문자열 변수 선언의 일반적인 방법
var emptyString string = &quot;&quot; // 문자열 변수를 하나 선언하고 빈 문자열로 초기화 한다.
func test() {
    no, yes maybe := &quot;no&quot; &quot;yes&quot; &quot;maybe&quot;   // 단축선언, 동시에 여러 변수를 선언 및 초기화    
    japaneseHello := &quot;Konichiwa&quot;          // 선언 및 초기화
    frenchHello = &quot;Bonjour&quot;               // 문자열 대입
}
</code></pre>

<blockquote>
<p>Go 언어에서 문자열은 절대 변경할 수 없습니다.</p>
</blockquote>

<p>예를들어 다음 코드는 컴파일시 오류가 발생 합니다.</p>

<pre><code class="language-go">var s string = &quot;hello&quot;
s [0] = 'c'
</code></pre>

<p>오류내용 : <code>can not assign to s [0]</code></p>

<p>하지만, 프로그래밍 중에 실제로 문자열 값을 바꿀려면 다음과 같이 사용하면 됩니다.</p>

<pre><code class="language-go">s := &quot;hello&quot;
c := []byte(s)        // 문자열 s를 []byte 형 배열로 변환
c [0] = 'c'           // 배열 인덱스로 값 변경 
s2 := string(c)       // 배열을 다시 string 형식으로 변환 
fmt.Printf( &quot;%s \n&quot;, s2)
</code></pre>

<p>Go는 <code>+</code> 연산자를 사용하여 문자열을 연결할 수 있습니다.</p>

<pre><code class="language-go">s := &quot;hello&quot;
m := &quot;world&quot;
a := s + m
fmt.Printf ( &quot;%s \n&quot;, a)
</code></pre>

<p>문자열을 수정할 경우 이런 방법도 사용할 수 있습니다.</p>

<pre><code class="language-go">s := &quot;hello&quot;
s = &quot;c&quot; +  s[1:]    // 문자열은 변경할 수 없지만 슬라이스를 이용할 순 있습니다.  
fmt.Printf( &quot;%s \n&quot;, s)
</code></pre>

<p>만약 여러 줄에 걸쳐서 문자열을 선언하고 싶다면 ``(백틱) 로 선언 할 수 있습니다. (모든 제어문자 무시)</p>

<pre><code class="language-go">m := `hello
      world`
</code></pre>

<p>`<code>로 둘러싸인 문자열은</code>Raw 문자열<code>입니다. 즉, 문자열에서 나열된  형식</code>그대로 인식`하는 형식 입니다.<br />
문자열의 대체 치환 변경은 없습니다. 줄 바꿈문자(\n)는 그대로 출력 됩니다.</p>

<h3 id="오류-유형:2ef2f3fc9ee3102fd2ffea6f9cac38b4">오류 유형</h3>

<p>Go에는 <code>error</code>형이라는 내장 형식이 있습니다. 오류 정보의 처리에 사용 됩니다.<br />
또한 Go언어에는 <code>package</code>에서 오류 처리를 할수 있는 <code>errors</code>라는 패키지도 존재 합니다.</p>

<pre><code class="language-go">err := errors.New( &quot;emit macho dwarf : elf header corrupted&quot;)
if err != nil {
    fmt.Print(err)
}
</code></pre>

<h3 id="데이터의-실제-저장-방식:2ef2f3fc9ee3102fd2ffea6f9cac38b4">데이터의 실제 저장 방식</h3>

<p>아래의 그림은 <a href="http://research.swtch.com/">Russ Cox Blog</a>에 포함되어 있는 내용입니다.<br />
그중에서 <a href="http://research.swtch.com/godata">Go 데이터 구조</a>에 대한 내용 입니다.</p>

<p>기본 형식들이 실제 물리 메모리에 어떻게 관리되고 값을 저장하는지에 대해서 알 수 있습니다.</p>

<p><img src="http://xenostream.github.io/post/go-web-programming/images/2.2.basic.png" alt="" /><br />
그림 2.1 Go 데이터 저장 방식</p>

<h2 id="테크닉:2ef2f3fc9ee3102fd2ffea6f9cac38b4">테크닉</h2>

<h3 id="그룹화에-의한-선언:2ef2f3fc9ee3102fd2ffea6f9cac38b4">그룹화에 의한 선언</h3>

<p>Go언어에서는 여러개의 정수·변수를 선언하거나 여러개의 패키지를 import 문으로 선언할 때, <code>그룹화</code>를 이용할 수 있습니다.</p>

<p>예를 들어 다음과 같은 코드에서 그룹화를 이용해서 선언할 수 있습니다.(괄호 사용)</p>

<pre><code class="language-go">import &quot;fmt&quot;
import &quot;os&quot;

const i = 100
const pi = 3.1415
const prefix = &quot;Go_&quot;

var i int
var pi float32
var prefix string
</code></pre>

<p>상기의 코드를 그룹화를 이용하여 작성하면 다음과 같습니다.</p>

<pre><code class="language-go">import(
    &quot;fmt&quot;
    &quot;os&quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &quot;Go_&quot;
)

var(
    i int
    pi float32
    prefix string
)
</code></pre>

<h3 id="iota-열거형:2ef2f3fc9ee3102fd2ffea6f9cac38b4">iota 열거형</h3>

<p>Go 언어에는 <code>iota</code>라는 키워드가 있습니다. 이 키워드는 <code>열거형(enum)</code>을 선언 할 때 사용 됩니다.<br />
기본값은 0부터 시작하여 순차적으로 값이 1씩 증가 됩니다.</p>

<pre><code class="language-go">const(
    x = iota // x == 0
    y = iota // y == 1
    z = iota // z == 2
    w        // 상수 선언에서 값을 생략하면 기본값은 이전 값과 동일 합니다.  
             // 여기에서 z = iota 로 선언하고 있으므로, 다음값인 w == 3 입니다.  
             // 사실 예제에서  y와 z 값도 사실 &quot;= iota&quot;는 생략 할 수 있습니다.
)

const v = iota // const 키워드를 사용할 때마다, iota 값은 리셋됩니다. 즉,v == 0 입니다.

const(
    e, f, g = iota, iota, iota  // e = 0, f = 0, g = 0 iota 와 동일 합니다
)
</code></pre>

<p>다른 값으로 상수의 값을 설정한 것과 <code>iota</code>에 설정되어 있는 것을 제외하고,</p>

<blockquote>
<p>각 <code>const</code> 그룹의 시작 상수는 기본적으로 0 입니다.</p>
</blockquote>

<p>두번째 이후의 상수는 이전 상수 값을 기본값으로 사용 합니다.<br />
이전 상수의 값이<code>iota</code>면 후의 값도<code>iota</code> 입니다.</p>

<h3 id="go-프로그램의-디자인-규칙:2ef2f3fc9ee3102fd2ffea6f9cac38b4">Go 프로그램의 디자인 규칙</h3>

<p>Go 언어가 간결함을 유지할 수 있는 것은 다음과 같은 기본적인 규칙들이 있기 때문입니다.</p>

<ul>
<li>대문자로 시작하는 변수는 외부에 공개 됩니다. (Public)<br />
즉, 다른 패키지에서 읽을 수있는 <code>공용 변수</code>라는 의미 입니다. 소문자로 시작하는 변수는 외부에서 접근할 수 없습니다.<br />
즉, <code>내부 변수</code>입니다.( Public / Private 에 해당)<br /></li>
<li>대문자로 시작하는 함수 또한 마찬가지 입니다.<br />
대문자로 시작하는 변수/함수는 객체지향언어 에서 <code>class</code>의 <code>public</code> 키워드와 동일한 의미 입니다.<br />
소문자로 시작하는 변수/함수는 <code>private</code> 키워드와 그 의미가 동일 합니다.<br /></li>
</ul>

<h2 id="array-slice-map:2ef2f3fc9ee3102fd2ffea6f9cac38b4">array, slice, map</h2>

<h3 id="array:2ef2f3fc9ee3102fd2ffea6f9cac38b4">array</h3>

<p><code>array</code> 는 <strong>배열</strong> 입니다. 배열형의 정의는 다음과 같습니다.</p>

<pre><code class="language-go">var arr[n] type
</code></pre>

<blockquote>
<p>배열은 반드시 [n]과 같이 <strong>크기</strong>가 지정 됩니다.!!</p>
</blockquote>

<p><code>[n] type</code>에서 <code>n</code>은 배열의 길이를 나타 냅니다. <code>type</code>은 배열 항목의 개별 형식을 의미 합니다.<br />
배열에 대한 조작 방식은 다른 언어와 비슷하며, <code>[]</code>을 통해서 값을 대입하거나 추출 합니다.</p>

<pre><code class="language-go">var arr[10] int     // int 형의 배열을 선언 합니다.
arr [0] = 42        // 배열의 인덱스는 0부터 시작 합니다.
arr [1] = 13        // 대입
fmt.Printf(&quot;The first element is %d \n&quot;, arr[0]) // 데이터를 추출하여 42를 반환 합니다.
fmt.Printf(&quot;The last element is %d \n&quot;, arr[9]) 
// 값이 할당되지 않은 마지막 요소를 반환 합니다. 초기화를 하지 않았으므로, 0이 반환 됩니다.  
</code></pre>

<p><code>길이값은 배열의 일부</code>이므로 <code>[3]int</code> 과 <code>[4]int</code> 는 완전히 다른 형식 입니다.배열도 <em>길이를 변경할 수 없습니다</em>.<br />
배열간의 대입은 <code>값으로 전달</code> 합니다. 즉,배열이 함수의 인수로 사용 된  경우 전달 되는 값은, 배열의 <strong>복사본</strong>이며,<br />
타언어에서와 같이 포인터가(레퍼런스) 아닙니다. 만약 포인터형식으로 사용 하려면 뒤에 소개하는 <code>slice</code>를  이용 하십시오.</p>

<p>배열 또한 <code>:=</code>로 단축선언 할 수 있습니다.</p>

<pre><code class="language-go">a := [3]int{1, 2, 3}     // 길이가 3인 int 배열을 선언하면서 값으로 초기화 합니다.  
b := [10]int{1, 2, 3}    // 길이가 10의 int 배열을 선언하고 초기화 합니다.   
                         // 이 중 3 가지 요소의 초기 값은 1,2,3이고, 나머지는 0입니다.  
c := [...]int{4, 5, 6}   // 길이값에 `...`를 사용해서 크기를 자동계산 할 수 있습니다.    
</code></pre>

<p>만약 <code>배열의 배열</code>을 사용할 수도 있습니다. Go는 중첩배열을 지원 합니다.<br />
예를 들어 다음 코드는 이차원 배열을 선언하고 있습니다.</p>

<pre><code class="language-go">// 이차원 배열을 하나 선언 합니다. 이 배열은 두 개의 배열을 요소로하고 
// 각 배열에는 4 개의 int 형의 요소가 포함되어 있습니다.
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 위의 선언은 단순화 할 수 있습니다.
easyArray := [2][4]int{ {1, 2, 3, 4}, {5, 6, 7, 8}}
</code></pre>

<p>배열의 상태는 다음과 같습니다.</p>

<p><img src="http://xenostream.github.io/post/go-web-programming/images/2.2.array.png" alt="" /></p>

<p>그림 2.2 다차원 배열의 매핑 관계</p>

<h3 id="slice:2ef2f3fc9ee3102fd2ffea6f9cac38b4">slice</h3>

<p>많은 응용 프로그램에서 배열만 사용해서는 요구사항을 모두 충족할 수 없습니다.때로는 어느 정도 크기의 배열이<br />
필요할지 모르는 경우도 존재하기 때문입니다. 따라서 &ldquo;동적 배열&rdquo;이 필요 합니다.<br />
Go는 이러한 <code>동적 배열</code>을 가능하게 만들어 주는 데이터 구조를 <code>slice</code>라고 합니다.</p>

<p><code>slice</code>는 진정한 의미의 동적 배열은 아닙니다. 단순한 참조형식 일 뿐입니다.<br />
<code>slice</code>는 실제로는 <code>array</code>형태로 내부적으로 처리 됩니다.<br />
&gt;<code>slice</code> 선언은  <code>array</code>와 같이 <strong>길이를 지정할 필요가 없습니다.</strong></p>

<pre><code class="language-go">// array 선언과 동일하지만 길이를 지정하지 않습니다.   
var fslice[] int
</code></pre>

<p><code>slice</code>를 선언함과 동시에 데이터를 초기화 합니다.</p>

<pre><code class="language-go">slice := []byte { 'a', 'b', 'c', 'd'}
</code></pre>

<p><code>slice</code>는 배열 또는 이미 존재하는 <code>slice</code> 내부에서도 선언 할 수 있습니다.<br />
<code>slice</code>는 <code>array[i:j]</code>형식으로 그 값을 얻을 수 있습니다. <code>i</code>는 배열의 시작 위치이며, <code>j</code>는 끝위치 입니다.<br />
그러나 <code>array[j]</code>는 그 값에 포함되지 않습니다. 즉, 길이는 <code>j-i</code> 입니다.</p>

<pre><code class="language-go">// 10개의 요소를 선언 합니다. 요소의 형태는 byte의 배열 입니다.
var ar = [10] byte{ 'a', 'b', 'c', 'd', 'e',​​ 'f', 'g', 'h' 'i', 'j'}

// byte를 포함한 2 개의 slice를 선언 합니다
var a, b []byte

// ar 슬라이스의 세 번째 요소에서 시작하여 5 번째 요소       
a = ar[2 : 5]

// 현재 a 변수가 가지는 값은  ar[2] ar[3]과 ar[4] 입니다.     

// b는 배열 ar의 또 다른 slice입니다.
b = ar[3 : 5]

// b의 요소는 ar[3]과 ar[4]입니다.
</code></pre>

<blockquote>
<p><code>slice</code>와 <code>array</code>는 선언시에 길이값으로
구분되므로 주의 하시기 바랍니다.</p>
</blockquote>

<p>배열은 선언 할 때 괄호안에([]) 배열의 길이를 명시하거나 <code>...</code> 를 사용해서 자동으로 길이를 계산 합니다.<br />
한편 <code>slice</code>를 선언 할 때는 괄호([]) 안에 크기를 지정하는 문자가 없습니다.</p>

<p>이러한 데이터 구조는 다음과 같이되어 있습니다.</p>

<p><img src="http://xenostream.github.io/post/go-web-programming/images/2.2.slice.png" alt="" /></p>

<p>그림 2.3 slice와 array의 대응 관계도</p>

<p>slice는 다음과 같이 사용됩니다.</p>

<p>-<code>slice</code>의 기본 시작 위치는 암시적으로 0 입니다. <code>ar[:n]</code>은 <code>ar[0:n]</code>과 같습니다.<br />
 -<code>slice</code>의 두 번째 값은 배열의 길이를 의미 합니다. <code>ar[n:]</code> 은 <code>ar[n:len(ar)]</code>과 같습니다.<br />
 - 만약 <code>slice</code>의 모든값이 필요할 경우 경우에는, <code>ar[:]</code>라는 형태로 사용 할 수 있습니다.<br />
   왜냐하면 기본 시작 값은 0이고, 두 번째는 배열의 길이에 해당하기때문 입니다. 즉<code>ar[0:len(ar)]</code>과 같습니다.</p>

<p>다음은 <code>slice</code>로 작업하는 몇가지 예제 입니다.</p>

<pre><code class="language-go">// 배열을 선언
var array = [10] byte{ 'a', 'b', 'c', 'd', 'e',​​ 'f', 'g', 'h' 'i', 'j'}
// slice를 2 개 선언
var aSlice, bSlice []byte

// 조작 
aSlice = array[3]  // aSlice = array[0:3]과 동일.  aSlice 요소: a, b, c
aSlice = array[5:] // aSlice = array[5:10]과 동일. aSlice 요소: f, g, h, i, j
aSlice = array[:]  // aSlice = array[0:10]과 동일. aSlice에는 모든 요소가 포함되어 있습니다.

// slice에서 slice를 추출 
aSlice = array[3:7]  // aSlice 요소: d, e, f, g, len = 4, cap = 7
bSlice = aSlice[1:3] // bSlice에는 aSlice[1] aSlice[2]가 포함되며 각각의 요소는 다음과 같습니다 : e, f
bSlice = aSlice[3]   // bSlice에는 aSlice[0], aSlice[1] aSlice[2]가 포함됩니다. 각각 다음과 같습니다 : d, e, f
bSlice = aSlice[0:5] // slice의 cap의 범위 내에서 확장 할 수 있습니다. bSlice는 다음 요소가 포함됩니다 : d, e, f, g, h
bSlice = aSlice[:]   // bSlice에는 aSlice의 모든 요소를​​ 포함합니다 : d, e, f, g
</code></pre>

<blockquote>
<p><code>slice</code>는 <strong>참조 형</strong>이므로, 값을 변경하면
다른 모든 참조에서도 값이 변경 됩니다.</p>
</blockquote>

<p>예를 들어 위의 <code>aSlice</code>와 <code>bSlice</code>에서 <code>aSlice</code>의 요소를 변경하면 <code>bSlice</code>의 해당 값도 변경 됩니다.</p>

<p>개념적으로는 <code>slice</code>는 구조체 입니다. 이 구조체에는 3 개의 요소가 포함되어 있습니다.<br />
- 첫번째는, 포인터 입니다. 배열의 <code>slice</code>가 나타내는 시작 위치를 가리 킵니다.<br />
- 두번째는, 길이, 즉 <code>slice</code>의 길이 입니다.<br />
- 세번째는, 최대 길이, <code>slice</code>의 시작 위치에서 배열의 마지막 위치까지의 길이 입니다.</p>

<pre><code class="language-go">Array_a := [10]byte{ 'a', 'b', 'c', 'd', 'e',​​ 'f', 'g', 'h' 'i', 'j'}
Slice_a := Array_a[2:5]
</code></pre>

<p>위 코드의 데이터 저장 구조는 다음 그림과 같습니다.</p>

<p><img src="http://xenostream.github.io/post/go-web-programming/images/2.2.slice2.png" alt="" /></p>

<p>그림 2.4 slice에 대응되는 배열정보</p>

<p><code>slice</code>에는 몇 가지 유용한 내장 함수가 있습니다.</p>

<p>-<code>len()</code>     <code>slice</code>의 길이를 반환 합니다.<br />
-<code>cap()</code>     <code>slice</code>의 최대 용량을 반환 합니다.<br />
-<code>append()</code>  <code>slice</code>에 하나 이상의 요소를 추가합니다. 그 후<code>slice</code>와 같은 형태의<code>slice</code>을 반환 합니다.<br />
-<code>copy()</code>    원래<code>slice</code>의 <code>src</code>를 <code>dst</code>요소에 복사하고 복사 된 요소의 개수를 반환 합니다.</p>

<p><code>append</code> 함수는 <code>slice</code>가 참조하는 배열의 <strong>내용</strong>을 변경하는 것입니다.<br />
따라서 참조와 동일한 배열의 다른<code>slice</code>에도 영향을 줍니다. 그러나<code>slice</code>에 공간이 없는(<code>(cap-len) == 0</code>) 경우<br />
동적 메모리에 새로운 배열 공간이 할당 됩니다. 반환되는 <code>slice</code> 배열의 포인터는 이 공간을 가리키고 있습니다.<br />
또한 원래 배열의 내용은 바뀌지 않습니다. 이 배열을 참조하는 다른<code>slice</code>은 영향을 받지 않게 됩니다.</p>

<p>Go 1.2에서 부터, slice는 3개의 인수를 사용하는 slice를 지원합니다.</p>

<p>이전까지 다음과 같은 방법으로 slice 또는 array에서 slice를 제거 했습니다.</p>

<pre><code class="language-go">var array [10]int
slice := array[2:4]
</code></pre>

<p>이 예제는 slice의 요소 수는 8이고, 새 버전에서는 다음과 같이 요소 수를 지정할 수 있습니다.</p>

<pre><code>slice = array[2:4:7]
</code></pre>

<p>예제에서 요소 수는 <code>7-2</code>, 즉 5입니다. 이렇게 생성된 새로운 slice는 마지막 3 가지 요소에 액세스하는 방법이 없습니다.</p>

<p>만약 slice가 <code>array[:i:j]</code> 같은 형식이라면 첫 번째 인수를 기본으로 간주하며, 기본값은 0 입니다.</p>

<h3 id="map:2ef2f3fc9ee3102fd2ffea6f9cac38b4">map</h3>

<p><code>map</code>의 개념은 Python 사전과 동일 합니다. 이 형식은 <code>map[keyType]valueType</code> 입니다.</p>

<p>아래의 코드를 참조 하시기 바랍니다.<br />
<code>map</code>의 사용법은 <code>slice</code>와 <strong>유사</strong>합니다. 단지  <code>key</code> 값을 통해서 데이터를 조작 합니다.<br />
차이점은 <code>slice</code>의 <code>index</code>는 <code>int</code>유형 이어야만 합니다. <code>map</code>의 <code>index</code>는 많은 형태가 있습니다.<br />
<code>int</code>도 될 수 있으며, <code>string</code> , <code>==</code>와 <code>!=</code> 등 연산자가 정의되어 있는 어떤 형태라도 가능합니다.</p>

<pre><code class="language-go">// key가 문자열이며 값은 int인 map을 선언합니다.    
// 이 Map은 사용하기 전에 `make로 초기화` 되어야 합니다.
var numbers map[string] int

// 또 다른 map의 선언 방법
numbers := make(map[string] int)
numbers[ &quot;one&quot;] = 1           // 대입
numbers[ &quot;ten&quot;] = 10          // 대입
numbers[ &quot;three&quot;] = 3

fmt.Println( &quot;세 번째 숫자는 :&quot;, numbers[&quot;three&quot;])   // 데이터 검색
// &quot;세 번째 숫자는 : 3&quot; 라는 형식으로 출력 됩니다.
</code></pre>

<p>이 <code>map</code> 은 일반적으로 사용하는 표와 아주 유사하며, 열값에 <code>key</code>, 행값에 <code>value</code> 값이 있습니다.</p>

<p>map을 사용할 경우 몇가지 주의사항이 있습니다.</p>

<ul>
<li><code>map</code>은 데이터의 순서가 없습니다.<br />
<code>map</code>의 출력 내용은 매번 다르게 출력될 수 있습니다.<br /></li>
<li><code>index</code>로 값을 얻을 수 없으며 항상 <code>key</code>를 사용해서 값을 추출해야 합니다.<br /></li>
<li><code>map</code>의 길이는 고정되지 않습니다.<br />
이점은 <code>slice</code>와 같으며, 참조 형의 일종 입니다.<br /></li>
<li>내장 <code>len()</code> 함수를 <code>map</code>에 적용하면 <code>map</code>이 가지는 <code>key</code>의 개수를 반환 합니다.<br />
-<code>map</code>값은 쉽게 다룰 수 있습니다.<br />
<code>numbers[&quot;one&quot;] = 11</code>와 같이 key가 <code>one</code>인 사전의 값을 <code>11</code>로 변경 합니다.<br />
-<code>map</code>은 다른 기본형과 달리, <code>thread-safe</code>하지 않습니다.<br />
즉, 여러 go-routine을 다룰 때는 반드시 mutex lock 메커니즘을 사용해야만 합니다.<br /></li>
</ul>

<p><code>map</code> 초기화는 <code>key:val</code> 방법으로 초기 값을 줄 수 있습니다.<br />
또한 동시에 <code>map</code>에는 기본적으로 <code>key</code>가 존재하는지 확인하는 방법이 존재 합니다.</p>

<p><code>delete</code>함수로 <code>map</code> 요소를 삭제 합니다.</p>

<pre><code class="language-go">// 사전을 초기화 합니다.
rating := map[string] float32{ &quot;C&quot;: 5, &quot;Go&quot;: 4.5 &quot;Python&quot;: 4.5 &quot;C ++&quot;: 2}

// map은 2 개의 반환 값을 가집니다. 첫번째는 해당 키의 값이며, 두 번째 반환 값은 
// 만약 key가 존재하지 않으면 false가 존재하면 true 값을 반환 합니다.   
csharpRating, ok := rating[&quot;C#&quot;]
if ok {
    fmt.Println(&quot;C# is in the map and its rating is&quot;, csharpRating)
} else {
    fmt.Println(&quot;We have no rating associated with C# in the map&quot;)
}

delete(rating &quot;C&quot;) // key가 C의 요소를 제거 합니다.  
</code></pre>

<p>위에서 말한 것처럼 <code>map</code>은 참조 형의 일종이기 때문에 만약 2 개의 <code>map</code>이 동일한 포인터를 가리키는<br />
경우 하나를 변경한다면 또다른 맵의 값도 변경 됩니다.</p>

<pre><code class="language-go">m := make(map[string] string)
m[&quot;Hello&quot;] = &quot;Bonjour&quot;
m1 := m
m1[&quot;Hello&quot;] = &quot;Salut&quot;      // 이때 m[&quot;hello&quot;] 값도 변경 됩니다. 
</code></pre>

<h3 id="make-new-메모리-조작:2ef2f3fc9ee3102fd2ffea6f9cac38b4">make, new 메모리 조작</h3>

<p><code>make</code>은 <code>map</code>, <code>slice</code> 및<code>channel</code>의 메모리를 생성 및 할당 합니다.<br />
<code>new</code>는 각 형태의 메모리를 생성 및 할당 합니다.</p>

<p>내장 함수 <code>new()</code>는 다른 언어에서 사용되는 메모리할당문인 <code>new()</code> 함수와 동일 합니다.<br />
<code>new(T)</code>는 0으로 초기화된 <code>T</code> 형의 메모리 공간을 할당한 후 그 주소를 반환 합니다. 즉 <code>*T</code> 형 값입니다.<br />
Go용어로 말하면, 포인터를 반환하는 것입니다. 새롭게 할당 된 타입 <code>T</code>는 0 입니다.</p>

<blockquote>
<p>중요한 점은 <code>new</code>는 포인터를 반환 합니다.</p>
</blockquote>

<p>내장 함수<code>make(T, args)</code>는 <code>new(T)</code>와는 다른 기능을 가지고 있습니다.<br />
make는 <code>slice</code>, <code>map</code> 또는<code>channel</code>을 만들고 초기값(0이 아닌 값)을 가진<code>T</code> 형을 반환하므로, <code>*T</code>가 없습니다.<br />
기본적으로 이 3 가지 형태가 다른 점은 데이터 구조를 가리키는 참조가 사용되기 전에 초기화되느냐의 여부입니다.<br />
예를 들어, 데이터(내부<code>array</code>)를 가리키는 포인터, 길이, 용량에 따른 3 가지로 설명되는 <code>slice</code>의 각 항목이<br />
초기화되기 전에는 <code>slice</code>의 값은 <code>nil</code> 입니다. <code>slice</code>, <code>map</code>, <code>channel</code>에서, make는 내부 데이터 구조를<br />
초기화하고 적당한 값으로 대입됩니다.</p>

<blockquote>
<p><code>make</code>는 초기화를 수행한 후 값을 반환 합니다.</p>
</blockquote>

<p>다음 그림은 <code>new</code>와 <code>make</code>의 차이점에 대해서 자세히 설명하고 있습니다.</p>

<p><img src="http://xenostream.github.io/post/go-web-programming/images/2.2.makenew.png" alt="" /><br />
그림 2.5 make와 new 의 실제 메모리 할당 방식</p>

<h2 id="제로-값:2ef2f3fc9ee3102fd2ffea6f9cac38b4">제로 값</h2>

<p>&ldquo;제로 값&rdquo;은 값이 비어있다는 의미가 아니며, 암시적인 초기값 이라는 의미입니다.<br />
이것은 &ldquo;변수의 생성시 초기&rdquo;의 기본값이며, 일반적으로 0 입니다.  각 유형별 제로 값은 다음과 같습니다.</p>

<pre><code class="language-go">int          0
int8         0
int32        0
int64        0
uint         0x0
rune         0      // rune의 실제 형태는 int32입니다.
byte         0x0    // byte의 실제 형태는 uint8입니다.
float32      0      // 길이는 4 byte
float64      0      // 길이는 8 byte
bool         false
string       &quot;&quot;
</code></pre>

  </section>
  <footer>
    
    <hr/>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'xenostream';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
    <section class="author-info row">
      <div class="author-avatar col-md-2">
        
      </div>
      <div class="author-meta col-md-6">
        
        
      </div>
      
    </section>
    <ul class="pager">
      
      <li class="previous"><a href="http://xenostream.github.io/2016/02/go-web-programming-02/03-control-statements-and-functions"><span aria-hidden="true">&larr;</span> Older</a></li>
      
      
      <li class="next"><a href="http://xenostream.github.io/2016/02/go-web-programming-02/01-hello-go">Newer <span aria-hidden="true">&rarr;</span></a></li>
      
    </ul>
  </footer>
</article>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      &copy;Xenostream.com. &reg;2017 All Rights Reserved.
    </div>
    <div class="sns-links hidden-print">
  
  <a href="http://xenostream.github.io/2016/02/about">
	  <i class="fa fa-user-md fa-fw"></i>
  </a>
  
  
  <a href="http://xenostream.github.io/tags">
	  <i class="fa fa-tags"></i>
  </a>
  
  
  <a href="http://xenostream.github.io/post">
      <i class="fa fa-archive fa-fw"></i>
  </a>
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="http://xenostream.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>

