<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Mini Editor</title>
  <style>
    :root { --console-h: 200px; }
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      overflow: hidden;
      font-family: "Cascadia Mono", monospace;
      background: #1e1e1e;
    }
    #editor { height: calc(100vh - var(--console-h)); width: 100vw; transition: height 0.2s ease; }
    #console {
      height: var(--console-h); width: 100vw;
      background: #111; color: #0f0;
      display: flex; flex-direction: column;
      border-top: 1px solid #333;
      overflow: hidden; transition: height 0.2s ease;
    }
    #console-header {
      background: #222; padding: 4px 8px; font-size: 12px;
      user-select: none; display: flex; align-items: center; gap: 8px;
      cursor: pointer;
    }
    #toggle-btn { font-weight: 600; }
    .hint { color: #999; margin-left: auto; font-size: 11px; }
    #console-output { flex: 1; padding: 6px; overflow-y: auto; font-size: 13px; }
    #console-input { height: 80px; border-top: 1px solid #333; }
  </style>
  <!-- Monaco Editor CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
</head>
<body>
  <div id="editor"></div>
  <div id="console">
    <div id="console-header">
      <span id="toggle-btn">â–¼ Console</span>
      <span class="hint">í´ë¦­í•´ì„œ ì ‘ê¸°/í¼ì¹˜ê¸° â€¢ ğŸ“‚Ctrl+O ì—´ê¸° â€¢ ğŸ’¾Ctrl+S ì €ì¥ â€¢ â†©ï¸Ctrl+Z ë˜ëŒë¦¬ê¸° â€¢ â†ªï¸Ctrl+Shift+Z ì¬ì‹¤í–‰</span>
    </div>
    <div id="console-output"></div>
    <div id="console-input"></div>
  </div>

  <input type="file" id="fileInput" style="display:none" />

  <script>
    require.config({ paths: { vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs" } });

    let editor, jsConsole;
    let currentFileName = "untitled.txt";

    require(["vs/editor/editor.main"], function () {
      // ë©”ì¸ ì—ë””í„°
      editor = monaco.editor.create(document.getElementById("editor"), {
        value: `console.log("Hello World");`,
        language: "javascript",
        theme: "vs-dark",
        fontFamily: "Cascadia Mono, monospace",
        fontSize: 14,
        wordWrap: "on",
        folding: true,
        minimap: { enabled: true, side: "right" },
        lineNumbers: "on",
        cursorBlinking: "smooth",
        automaticLayout: true,        
      });

      // ì½˜ì†” ì…ë ¥ìš© ì—ë””í„°
      jsConsole = monaco.editor.create(document.getElementById("console-input"), {
        value: "// ì˜ˆ) 1,$ d â€¢ /foo/g,\"bar\" â€¢ console.log(\"hi\") â€¢  ì½”ë“œ ì…ë ¥ í›„ Enter (Shift+Enter = ì¤„ë°”ê¿ˆ)",
        language: "javascript",
        theme: "vs-dark",
        fontSize: 13,
        minimap: { enabled: false },
        lineNumbers: "off",
        wordWrap: "on",        
        automaticLayout: true,
      });

      // ë©”ì¸ ì—ë””í„° í¬ê¸° ìë™ ì¡°ì •
      const ro = new ResizeObserver(() => editor.layout());
      ro.observe(document.getElementById("editor"));

      // ì½˜ì†” ì…ë ¥ ì‹¤í–‰ (Enter ì‹¤í–‰, Shift+Enter ì¤„ë°”ê¿ˆ)
      jsConsole.onKeyDown(e => {
        if (e.keyCode === monaco.KeyCode.Enter) {
          if (e.shiftKey) return;
          const code = jsConsole.getValue();
          jsConsole.setValue("");
          runCode(code);
          e.preventDefault();
        }
      });
    });

    function log(msg) {
      const out = document.getElementById("console-output");
      out.innerHTML += msg + "<br>";
      out.scrollTop = out.scrollHeight;
    }

    // console.log ê°€ë¡œì±„ê¸°
    const origLog = console.log;
    console.log = (...args) => { origLog(...args); log(args.join(" ")); };

    // Ctrl+O / Ctrl+S
    const fileInput = document.getElementById("fileInput");
    window.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key.toLowerCase() === "o") { e.preventDefault(); fileInput.click(); }
      if (e.ctrlKey && e.key.toLowerCase() === "s") { e.preventDefault(); saveFile(); }
    });

    // íŒŒì¼ ì—´ê¸°
    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        editor.setValue(reader.result);
        currentFileName = file.name;
        const ext = file.name.split(".").pop().toLowerCase();
        let lang = "plaintext";
        if (ext === "js") lang = "javascript";
        else if (ext === "ts") lang = "typescript";
        else if (ext === "md") lang = "markdown";
        else if (ext === "cs") lang = "csharp";
        else if (ext === "html" || ext === "htm") lang = "html";
        else if (ext === "css") lang = "css";
        else if (ext === "json") lang = "json";
        else if (ext === "xml") lang = "xml";
        monaco.editor.setModelLanguage(editor.getModel(), lang);
        log(`íŒŒì¼ ë¡œë“œ ì™„ë£Œ: ${file.name} (ì–¸ì–´: ${lang})`);
      };
      reader.readAsText(file);
    });

    // íŒŒì¼ ì €ì¥
    function saveFile() {
      const text = editor.getValue();
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = currentFileName || "untitled.txt";
      a.click();
      URL.revokeObjectURL(url);
      log(`íŒŒì¼ ì €ì¥ ì™„ë£Œ: ${a.download}`);
    }

    // ì½”ë“œ ì‹¤í–‰ / ì •ê·œì‹ ì¹˜í™˜ ($ ì§€ì›)
    function runCode(code) {
      try {
        const model = editor.getModel();
    
        // ë²”ìœ„ ì‚­ì œ: 1,$ d / 10,20 d / 5 d
        const deleteMatch = code.match(/^(\d+|\$)(?:,(\d+|\$))?\s+d$/);
        if (deleteMatch) {
          const [, startStr, endStr] = deleteMatch;
          const start = startStr === "$" ? model.getLineCount() : parseInt(startStr, 10);
          const end   = endStr   === "$" ? model.getLineCount() : (endStr ? parseInt(endStr, 10) : start);
    
          const range = new monaco.Range(start, 1, end, model.getLineMaxColumn(end));
          editor.pushUndoStop();
          editor.executeEdits("console-delete", [{ range, text: "" }]);
          editor.pushUndoStop();
          log(`ì¤„ ${startStr}${endStr ? "~" + endStr : ""} ì‚­ì œ ì™„ë£Œ`);
          return;
        }
    
        // ë²”ìœ„ ì¹˜í™˜: 1,30 /^.../flags, "replacement"
        const rangeMatch = code.match(/^(\d+|\$)(?:,(\d+|\$))?\s+\/(.+)\/(\w*)\s*,\s*["'](.+)["']$/);
        if (rangeMatch) {
          const [, startStr, endStr, pattern, flags, replacement] = rangeMatch;
          const start = startStr === "$" ? model.getLineCount() : parseInt(startStr, 10);
          const end   = endStr   === "$" ? model.getLineCount() : (endStr ? parseInt(endStr, 10) : start);
          const regex = new RegExp(pattern, flags);
          const edits = [];
          for (let i = start - 1; i < end && i < model.getLineCount(); i++) {
            const lineContent = model.getLineContent(i + 1);
            const newContent = lineContent.replace(regex, replacement);
            if (newContent !== lineContent) {
              edits.push({
                range: new monaco.Range(i + 1, 1, i + 1, lineContent.length + 1),
                text: newContent,
                forceMoveMarkers: true
              });
            }
          }
          if (edits.length > 0) {
            editor.pushUndoStop();
            editor.executeEdits("console-replace", edits);
            editor.pushUndoStop();
            log(`ì¤„ ${startStr}${endStr ? "~" + endStr : ""} ì¹˜í™˜ ì™„ë£Œ: ${regex} â†’ "${replacement}"`);
          }
          return;
        }
    
        // ì „ì—­ ì¹˜í™˜: /^.../flags, "replacement"
        const globalMatch = code.match(/^\/(.+)\/(\w*)\s*,\s*["'](.+)["']$/);
        if (globalMatch) {
          const [, pattern, flags, replacement] = globalMatch;
          const regex = new RegExp(pattern, flags);
          const fullText = model.getValue();
          const newText = fullText.replace(regex, replacement);
          if (newText !== fullText) {
            editor.pushUndoStop();
            editor.executeEdits("console-replace", [
              { range: model.getFullModelRange(), text: newText, forceMoveMarkers: true }
            ]);
            editor.pushUndoStop();
            log(`ì „ì—­ ì¹˜í™˜ ì™„ë£Œ: ${regex} â†’ "${replacement}"`);
          }
          return;
        }
    
        // ì¼ë°˜ JS ì‹¤í–‰
        const result = eval(code);
        if (result !== undefined) log(String(result));
      } catch (err) {
        log("Error: " + err.message);
      }
    }
    
    // ìƒˆë¡œê³ ì¹¨(F5, Ctrl+R) ë°©ì§€ íŒì—…
    window.addEventListener("beforeunload", function (e) {
      e.preventDefault();
      e.returnValue = ""; // ë¸Œë¼ìš°ì €ê°€ ê¸°ë³¸ ê²½ê³ ì°½ì„ ë„ì›€
    });

    // ì½˜ì†” í† ê¸€ (CSS ë³€ìˆ˜ë¡œ ë†’ì´ ì œì–´)
    const rootStyle = document.documentElement.style;
    const toggleBtn = document.getElementById("toggle-btn");
    const header = document.getElementById("console-header");

    function setConsoleHeight(px) {
      rootStyle.setProperty("--console-h", px);
      requestAnimationFrame(() => editor && editor.layout());
    }

    header.addEventListener("click", () => {
      const collapsed = toggleBtn.textContent.startsWith("â–¼") ? false : true;
      if (!collapsed) {
        setConsoleHeight("25px");
        toggleBtn.textContent = "â–¶ Console";
      } else {
        setConsoleHeight("200px");
        toggleBtn.textContent = "â–¼ Console";
      }
    });
  </script>
</body>
</html>
