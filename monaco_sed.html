<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Mini FS Editor with sed Console + Download</title>
<style>
:root { --console-h: 150px; }

html, body {
  margin: 0; padding: 0;
  height: 100%; width: 100%;
  overflow: hidden;
  font-family: "Cascadia Code", monospace;
  background: #1e1e1e; color: #ddd;
}
#container { display: flex; height: 100vh; width: 100vw; }

/* 사이드바: 접기/펼치기 지원 */
#sidebar {
  width: 250px;
  background: #252526; border-right: 1px solid #333;
  display: flex; flex-direction: column;
  transition: width 0.2s ease;
  overflow: hidden;
}
#sidebar.collapsed { width: 0; }

/* 사이드바 옆 토글 버튼 */
#sidebar-toggle {
  width: 12px;
  background: #333;
  border: none;
  color: #eee;
  cursor: pointer;
  padding: 0;
}

#main { flex: 1; display: flex; flex-direction: column; min-width: 0; }
#editor {
  height: calc(100vh - var(--console-h));
  width: 100%;
  transition: height 0.2s ease;
}
#console {
  height: var(--console-h);
  background: #111; border-top: 1px solid #333;
  display: flex; flex-direction: column;
  transition: height 0.2s ease;
}
#console-toggle {
  background: #333; border: none; color: #eee;
  font-size: 12px; padding: 4px 8px; cursor: pointer;
  text-align: left; width: 100%;
}
#console-output {
  flex: 1; overflow-y: auto; font-size: 12px; padding: 6px; color: #0f0;
}
#console-input { height: 80px; border-top: 1px solid #333; }
#toolbar {
  display: flex; justify-content: space-around;
  padding: 6px; border-bottom: 1px solid #333;
}
#console-output::-webkit-scrollbar { width: 8px; }
#console-output::-webkit-scrollbar-track { background: #111; }
#console-output::-webkit-scrollbar-thumb { background-color: #222; border-radius: 4px; }
#console-output::-webkit-scrollbar-thumb:hover { background-color: #333; }
#toolbar button {
  background: none; border: none; color: #eee;
  font-size: 18px; cursor: pointer;
}
#toolbar button:disabled { opacity: 0.4; cursor: not-allowed; }
#file-list { flex: 1; overflow-y: auto; padding: 6px; font-size: 13px; }
.file-item { padding: 4px 8px; cursor: pointer; border-radius: 3px; user-select: none; }
.file-item:hover { background: #333; }
.file-item.active { background: #444; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
<script>
var defineBackup = window.define;
window.define = undefined;
</script>
<script src="https://biowasm.com/cdn/v3/aioli/latest/aioli.js"></script>
<script>
window.define = defineBackup;
</script>
</head>
<body>
<div id="container">
  <div id="sidebar">
    <div id="toolbar">
      <button id="btnNew" title="New">✨</button>
      <button id="btnDelete" title="Delete">🗑️</button>
      <button id="btnSave" title="Save (VFS)">💾</button>
      <button id="btnOpen" title="Open">📂</button>
      <button id="btnDownload" title="Download">⬇️</button>
    </div>
    <div id="file-list" aria-label="Files"></div>
  </div>
  <!-- 사이드바 옆 토글 버튼 -->
  <button id="sidebar-toggle">◀</button>
  <div id="main">
    <div id="editor"></div>
    <button id="console-toggle">▼ Console</button>
    <div id="console">
      <div id="console-output"></div>
      <div id="console-input"></div>
    </div>
  </div>
</div>
<input type="file" id="fileInput" style="display:none" />

<script>
require.config({ paths: { vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs" } });

let editor, jsConsole;
let currentFile = null;
const files = {};
let sedInst = null;
let sedReady = false;

// sed 초기화
async function initSed() {
  try {
    log("sed 초기화 중…");
    sedInst = await new Aioli(["sed/4.8"], { printInterleaved: false });
    sedReady = true;
    log("sed 준비 완료 ✅ (GNU sed 4.8)");
  } catch (e) {
    log("sed 초기화 실패: " + e.message);
  }
}
window.addEventListener("load", initSed);

require(["vs/editor/editor.main"], function () {
  editor = monaco.editor.create(document.getElementById("editor"), {
    value: "",
    language: "plaintext",
    theme: "vs-dark",
    fontSize: 14,
    wordWrap: "on",
    folding: true,
    minimap: { enabled: true },
    automaticLayout: false
  });

  jsConsole = monaco.editor.create(document.getElementById("console-input"), {
    value: "s/foo/bar/g",
    language: "shell",
    theme: "vs-dark",
    fontSize: 13,
    minimap: { enabled: false },
    lineNumbers: "off",
    wordWrap: "on",
    automaticLayout: false
  });

  const ro = new ResizeObserver(() => {
    editor.layout();
    jsConsole.layout();
  });
  ro.observe(document.getElementById("main"));
  ro.observe(document.getElementById("editor"));
  ro.observe(document.getElementById("console"));

  window.addEventListener("resize", () => {
    editor.layout();
    jsConsole.layout();
  });

  jsConsole.onKeyDown(async e => {
    if (e.keyCode === monaco.KeyCode.Enter && !e.shiftKey) {
      e.preventDefault();
      const code = jsConsole.getValue().trim();
      jsConsole.setValue("");
      await runSed(code);
    }
  });
});

function log(msg) {
  const out = document.getElementById("console-output");
  out.innerHTML += msg + "<br>";
  out.scrollTop = out.scrollHeight;
}

function refreshList() {
  const list = document.getElementById("file-list");
  list.innerHTML = "";
  const names = Object.keys(files);
  if (!names.length) {
    list.innerHTML = "<div style='color:#888;padding:6px'>파일이 없습니다. ✨ 또는 📂 버튼을 사용하세요.</div>";
    return;
  }
  names.forEach(fname => {
    const div = document.createElement("div");
    div.className = "file-item" + (fname === currentFile ? " active" : "");
    div.textContent = fname;
    div.onclick = () => openFile(fname);
    list.appendChild(div);
  });
}

function detectLanguage(fname) {
  const ext = fname.split(".").pop().toLowerCase();
  if (ext === "js") return "javascript";
  if (ext === "ts") return "typescript";
  if (ext === "md") return "markdown";
  if (ext === "cs") return "csharp";
  if (ext === "html" || ext === "htm") return "html";
  if (ext === "css") return "css";
  if (ext === "json") return "json";
  if (ext === "xml") return "xml";
  return "plaintext";
}

document.getElementById("btnNew").addEventListener("click", async () => {
  const fname = prompt("새 파일 이름:", "untitled.txt");
  if (!fname || files[fname]) { alert("파일 존재"); return; }
  files[fname] = "";
  currentFile = fname;
  editor.setValue("");
  monaco.editor.setModelLanguage(editor.getModel(), detectLanguage(fname));
  refreshList();
  log(`생성됨: ${fname}`);
  if (sedReady) await sedInst.fs.writeFile(fname, new TextEncoder().encode(""));
});

function openFile(fname) {
  currentFile = fname;
  const content = files[fname] ?? "";
  editor.setValue(content);
  monaco.editor.setModelLanguage(editor.getModel(), detectLanguage(fname));
  refreshList();
  log(`열림: ${fname}`);
}

// 삭제
document.getElementById("btnDelete").addEventListener("click", async () => {
  if (!currentFile) return alert("열린 파일 없음");
  delete files[currentFile];
  try { if (sedReady) await sedInst.fs.unlink(currentFile); } catch (e) {}
  currentFile = null;
  editor.setValue("");
  monaco.editor.setModelLanguage(editor.getModel(), "plaintext");
  refreshList();
  log("삭제됨 (VFS 포함)");
});

// 저장
document.getElementById("btnSave").addEventListener("click", async () => {
  if (!currentFile) return alert("열린 파일 없음");
  const text = editor.getValue();
  files[currentFile] = text;
  if (sedReady) await sedInst.fs.writeFile(currentFile, new TextEncoder().encode(text));
  log("저장됨: " + currentFile);
});

// 로컬 파일 열기
document.getElementById("btnOpen").onclick = () => {
  const input = document.getElementById("fileInput");
  input.value = "";
  input.click();
};
document.getElementById("fileInput").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = async () => {
    files[file.name] = reader.result;
    currentFile = file.name;
    editor.setValue(reader.result);
    monaco.editor.setModelLanguage(editor.getModel(), detectLanguage(file.name));
    refreshList();
    log(`로컬 파일 로드: ${file.name}`);
    if (sedReady) await sedInst.fs.writeFile(file.name, new TextEncoder().encode(reader.result));
  };
  reader.readAsText(file, "UTF-8");
});

// 다운로드 버튼
document.getElementById("btnDownload").addEventListener("click", () => {
  if (!currentFile) return alert("열린 파일 없음");
  const text = editor.getValue();
  const blob = new Blob([text], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = currentFile || "untitled.txt";
  a.click();
  URL.revokeObjectURL(url);
  log(`다운로드 완료: ${a.download}`);
});

// 콘솔 토글
const rootStyle = document.documentElement.style;
const toggleBtn = document.getElementById("console-toggle");
let collapsed = false;
function setConsoleHeight(px) {
  rootStyle.setProperty("--console-h", px);
  requestAnimationFrame(() => {
    editor.layout();
    jsConsole.layout();
    requestAnimationFrame(() => {
      editor.layout();
      jsConsole.layout();
    });
  });
}
toggleBtn.addEventListener("click", () => {
  collapsed = !collapsed;
  if (collapsed) {
    setConsoleHeight("0px");
    toggleBtn.textContent = "▶ Console";
  } else {
    setConsoleHeight("150px");
    toggleBtn.textContent = "▼ Console";
  }
});

// 사이드바 토글
const sidebar = document.getElementById("sidebar");
const sidebarToggle = document.getElementById("sidebar-toggle");
sidebarToggle.addEventListener("click", () => {
  const isCollapsed = sidebar.classList.toggle("collapsed");
  sidebarToggle.textContent = isCollapsed ? "▶" : "◀";
  requestAnimationFrame(() => {
    editor.layout();
    jsConsole.layout();
    requestAnimationFrame(() => {
      editor.layout();
      jsConsole.layout();
    });
  });
});

// 쉘 토큰화
function tokenize(str) {
  const re = /'([^']*)'|"([^"]*)"|(\S+)/g;
  const tokens = [];
  let match;
  while ((match = re.exec(str)) !== null) {
    if (match[1] !== undefined) tokens.push(match[1]);
    else if (match[2] !== undefined) tokens.push(match[2]);
    else tokens.push(match[3]);
  }
  return tokens;
}

// sed 실행
async function runSed(cmd) {
  try {
    if (!sedReady) { log("sed가 아직 준비되지 않았습니다."); return; }
    if (!cmd.startsWith("sed")) cmd = "sed " + cmd;
    if (!currentFile) { log("열린 파일 없음"); return; }

    // 현재 에디터 내용을 VFS에 반영
    const text = editor.getValue();
    await sedInst.fs.writeFile(currentFile, new TextEncoder().encode(text));

    const args = tokenize(cmd);
    const result = await sedInst.exec("sed", [...args.slice(1), currentFile]);

    if (result && result.stdout) {
      const model = editor.getModel();
      const fullRange = model.getFullModelRange();
      editor.executeEdits("sed-replace", [{ range: fullRange, text: result.stdout }]);
      files[currentFile] = result.stdout;
      await sedInst.fs.writeFile(currentFile, new TextEncoder().encode(result.stdout));
    }
    if (result && result.stderr) log("stderr: " + result.stderr);
    log(`실행됨: ${cmd}`);
  } catch (e) { log("Error: " + e.message); }
}

// Undo/Redo 단축키
window.addEventListener("keydown", (e) => {
  if (!editor) return;
  if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === "z") {
    e.preventDefault();
    editor.trigger("keyboard", "undo", null);
  }
  if ((e.ctrlKey && e.shiftKey && e.key.toLowerCase() === "z") || (e.ctrlKey && e.key.toLowerCase() === "y")) {
    e.preventDefault();
    editor.trigger("keyboard", "redo", null);
  }
});

// 종료 경고
window.addEventListener("beforeunload", (e) => {
  e.preventDefault();
  e.returnValue = "";
});
</script>
</body>
</html>
