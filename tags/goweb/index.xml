<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Goweb on XenoStream&#39;s Private Site</title>
    <link>http://xenostream.github.io/tags/goweb/</link>
    <description>Recent content in Goweb on XenoStream&#39;s Private Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy;Xenostream.com. &amp;reg;2017 All Rights Reserved.</copyright>
    <lastBuildDate>Wed, 17 Feb 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://xenostream.github.io/tags/goweb/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go Web Programming: Perface</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-perface</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-perface</guid>
      <description>

&lt;h1 id=&#34;go언어로-웹-프로그램-만들기:04c6e90faac2675aa89e2176d2eec7d8&#34;&gt;Go언어로 웹 프로그램 만들기&lt;/h1&gt;

&lt;h1 id=&#34;perface:04c6e90faac2675aa89e2176d2eec7d8&#34;&gt;Perface&lt;/h1&gt;

&lt;p&gt;Go언어를 학습함에 있어서 주제를 하나 정한 후, 여러가지 기술을 사용해서 학습하는&lt;br /&gt;
방법이 가장 효율적이라 생각되며, 이에, 웹 응용프로그램을 작성하는 것으로&lt;br /&gt;
Go언어를 학습 하겠습니다.&lt;/p&gt;

&lt;p&gt;기본적으로 다음과 같은 사항이 요구됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;웹 기본 기술에 대하여 알고 있어야 합니다.&lt;/li&gt;
&lt;li&gt;언어에 대하여 기본적인 지식이 있어야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;Hello, Go world!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/My.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.xenostream.com&#34;&gt;XenoStream&lt;/a&gt;
######2016@ powered by &lt;a href=&#34;mailto://piljin.kwon@gmail.com&#34;&gt;PilJin.Kwon&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [01/00] Intro</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-01/00-intro</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-01/00-intro</guid>
      <description>

&lt;h1 id=&#34;intro:6a07050414416ef66304d8a9113cb88a&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;먼저, &lt;code&gt;Go언어&lt;/code&gt;의  세계로 오신걸 &lt;code&gt;환영&lt;/code&gt;합니다!!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;21세기 C언어&lt;/code&gt;라고 불리는 Go언어는 빠른 컴파일 시간과, 실행파일 내에 가베지 컬렉터를 내장하고 있으며,&lt;br /&gt;
동시성 프로그래밍이 언어의 기본 기능으로 장착되어 있는 현대적인 언어 입니다.&lt;/p&gt;

&lt;p&gt;대표적으로 다음과 같은 Go언어만의 장점이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;아주 큰 프로젝트도 몇 초만에 컴파일 할 수 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C언어의 문제점 중 하나인 헤더파일이 혼재된 상황이 발생하지 않습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;정적타입 언어이므로, 타입 혼재로 인한 혼란이 야기되지 않습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;경량의 객체지향 프로그래밍이 가능 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;쓰레기 수집기능이 실행파일 내에 내장되므로, 별도의 메모리 관리가 필요 없습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;GC기능 내장으로 고루틴 및 채널의 기능이 강화 됩니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;최신의 하드웨어 사양인 멀티코어를 언어 수준에서 지원 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Go언어는 &lt;strong&gt;컴파일형 언어&lt;/strong&gt;입니다.!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;동적 언어의 빠른 개발 효율과 정적 언어의 속도 및 안정성 등의 장점만을 흡수하여 개발된 언어 입니다.&lt;br /&gt;
또한 최신의 IT환경에 맞도록, 멀티 코어와 네트워크에 최적화된 개발 언어입니다.&lt;/p&gt;

&lt;p&gt;풍부한 표현식, 경량의 타입시스템, 네이티브 동시성 모델 지원, 가베지 콜렉션 메모리 자동관리 등이
언어에서 기본적으로 지원하고 있습니다. 다른언어에서는 이러한 기능을 &lt;code&gt;패키지&lt;/code&gt;나 &lt;code&gt;툴&lt;/code&gt;로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;1장에서는 이러한 &lt;code&gt;Go&lt;/code&gt;언어를 시스템에 설치하고 환경 설정하는 것에 대해서 설명하도록 하겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [01/01] Installation</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-01/01-installation</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-01/01-installation</guid>
      <description>

&lt;h1 id=&#34;installation:ff14a3c2d45e25c07d33525472b59348&#34;&gt;Installation&lt;/h1&gt;

&lt;h2 id=&#34;3가지-설치-방법:ff14a3c2d45e25c07d33525472b59348&#34;&gt;3가지 설치 방법&lt;/h2&gt;

&lt;p&gt;개발자의 컴퓨터에 &lt;code&gt;Go언어&lt;/code&gt;를 위한 개발환경을 구축하는 방법에는 여러가지가 존재합니다.&lt;br /&gt;
그중 대표적인 3가지 방법에 알아보도록 하겠습니다.&lt;br /&gt;
물론 이 3가지 방법이 정석은 아니며, 개발자의 능력대로 수동으로 설치해도 아무런 문제가 없습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Go언어의 &lt;code&gt;공식 설치 패키지&lt;/code&gt; 이용&lt;br /&gt;
Go언어의 공식 홈페이지에서 윈도우/리눅스/매킨토시용으로 다운로드 한 후 설치하는&lt;br /&gt;
가장 표준적인 방법 입니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;소스코드에서 컴파일 한 후 직접 설치&lt;br /&gt;
개발자에게 친숙한 방법으로, 유닉스에서 일반적인 패키지를 설치하는 방법과 동일 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;제3자 유틸리티를 이용해서 설치&lt;br /&gt;
Go언어를 설치하는 방법은 운영체제마다 별도의 패키지 설치용 도구를 이용 합니다.&lt;br /&gt;
예를들어, 우분투 리눅스 계열의 &lt;code&gt;apt-get&lt;/code&gt;과 맥OS의 &lt;code&gt;homebrew&lt;/code&gt;등을 이용하는 방법 입니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;어떠한 방법을 사용해서라도 설치하면 동일한 개발 환경을 갖추게 됩니다. 이제 각각의 방법에 대하여,&lt;br /&gt;
간단히 설명하도록 하겠습니다. 하기의 방법은 시간이 지나면 변할 수도 있으니, 참고하시기 바랍니다.&lt;/p&gt;

&lt;h3 id=&#34;소스코드로-설치:ff14a3c2d45e25c07d33525472b59348&#34;&gt;소스코드로 설치&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Go언어&lt;/code&gt;의 일부분은 &lt;code&gt;Plan 9 C&lt;/code&gt; 컴파일러와 &lt;code&gt;AT&amp;amp;T&lt;/code&gt; 어셈블러를 이용해서 구현되어 있습니다.&lt;br /&gt;
소스코드에서  설치하기 위해서는 운영체제에 &lt;code&gt;C 컴파일러&lt;/code&gt;가 미리 설치되어 있어야만 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매킨토시&lt;/strong&gt;의 경우 XCode 툴을 설치하셨다면, 이미 C컴파일러 설치가 완료된 상황 입니다.&lt;br /&gt;
&lt;strong&gt;유닉스/리눅스&lt;/strong&gt;의 경우에는 &lt;code&gt;gcc&lt;/code&gt;를 설치하셔야  합니다.&lt;/p&gt;

&lt;p&gt;예를들어 우분투 리눅스에서는 &lt;code&gt;apt-get&lt;/code&gt; 명령어를 사용하여 gcc를 설치하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sudo apt-get install gcc libc6-dev    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;윈도우&lt;/strong&gt;의 경우에는 &lt;code&gt;MinGW&lt;/code&gt; 컴파일러를 설치하면  &lt;code&gt;gcc&lt;/code&gt;와 호환 됩니다.&lt;br /&gt;
또한, 사용하는 운영체제의 비트수에 맞는 컴파일러를 설치하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;만약, &lt;strong&gt;윈도우&lt;/strong&gt;를 사용하여 패키지를 설치한 경우에는 자동으로 환경변수가 등록 됩니다.&lt;br /&gt;
&lt;strong&gt;유닉스&lt;/strong&gt;류의 운영체제에서 설치할 경우에는 수동으로 &lt;code&gt;환경변수&lt;/code&gt;를 등록하여야 합니다.&lt;/p&gt;

&lt;p&gt;다음과 같은 명령을 사용하여 &lt;code&gt;수동으로 환경변수를 등록&lt;/code&gt;합니다.(&lt;code&gt;.bashrc / .bash_profile&lt;/code&gt; 파일)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   export GOROOT=$HOME/go  
   export GOBIN=$GOROOT/bin
   export PATH=$PATH:$GOROOT/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉘 상태에서 &lt;code&gt;go*&lt;/code&gt; 명령을 사용하면 다음과 같이 표시 됩니다.
&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/1.1.mac.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
&amp;lt;그림1.1&amp;gt; 소스코드로 설치한 후 go명령 입력화면&lt;/p&gt;

&lt;p&gt;상기와 같이 표시 되었다면 정상적으로 Go언어의 개발환경을 갖추게 된 것입니다.&lt;br /&gt;
만약  &lt;code&gt;no such command~~~~&lt;/code&gt; 와 같은 에러메세지가 표시 되었다면, &lt;code&gt;$PATH&lt;/code&gt; 환경변수를&lt;br /&gt;
살펴 보시기 바랍니다. Go언어가 설치된 디렉토리의 &lt;code&gt;bin&lt;/code&gt; 디렉토리에 경로가 설정되지 않아서&lt;br /&gt;
발생하는 문제 입니다.&lt;/p&gt;

&lt;h3 id=&#34;표준-설치-패키지로-설치:ff14a3c2d45e25c07d33525472b59348&#34;&gt;표준 설치 패키지로 설치&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Go언어&lt;/code&gt;는 단순 클릭만으로 시스템에 개발환경을 설치할 수있는 &lt;code&gt;표준 설치 패키지&lt;/code&gt;를&lt;br /&gt;
제공 합니다.(Mac / Windows / Linux / ARM / Mainframe&amp;hellip;)&lt;/p&gt;

&lt;p&gt;기본적으로 표준 설치 패키지는 &lt;code&gt;/usr/local/go&lt;/code&gt; (윈도우의 경우 &lt;code&gt;c:\Go&lt;/code&gt;) 디렉토리에 설치 합니다.&lt;br /&gt;
당연히, 상기의 경로는 설치과정에서 변경해서 사용할 수 있습니다. 물론 변경해서 설치 했다면,&lt;br /&gt;
환경변수들을 체크해 보시기 바랍니다.&lt;/p&gt;

&lt;h4 id=&#34;32비트-64비트-환경-알아내기:ff14a3c2d45e25c07d33525472b59348&#34;&gt;32비트 / 64비트 환경 알아내기.&lt;/h4&gt;

&lt;p&gt;다음단계로 진행할려면, 설치하는 &lt;code&gt;운영체제의 비트수&lt;/code&gt;가 문제가 되므로, 먼저 운영체제가 몇 비트로&lt;br /&gt;
운영 되는지를 알아 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;윈도우&lt;/strong&gt;의 경우에는 &lt;code&gt;윈도우키 + R&lt;/code&gt;을 눌르신 후, &lt;code&gt;systeminfo&lt;/code&gt; 명령을 입력 합니다.&lt;br /&gt;
&lt;code&gt;systeminfo&lt;/code&gt; 명령어는 현재 운영되는 운영체제에 대한 다양한 정보를 표시 합니다.&lt;br /&gt;
&lt;code&gt;시스템타입&lt;/code&gt;&lt;code&gt;부분을 찾아보시면,&lt;/code&gt;x64-based PC&lt;code&gt;라는 부분이 표시되면,&lt;/code&gt;64비트`` 운영체제 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매킨토시&lt;/strong&gt;의 경우는 32비트에서 벗어난지 오래되므로, &lt;code&gt;64비트 환경으로만 운영&lt;/code&gt; 됩니다.&lt;br /&gt;
&lt;strong&gt;리눅스/유닉스&lt;/strong&gt;의 경우에는 &lt;code&gt;uname -a&lt;/code&gt; 명령어를 입력하시면 운영되는 비트수가 표시 됩니다.&lt;br /&gt;
우분투 리눅스의 경우는 대체로 다음과 같은 문구가 표시되게 됩니다. 표시되는 내용을 다를 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;some description&amp;gt; x86_64 x86_64 x86_64 GNU/Linux
// some machines such as Ubuntu 10.04 will show as following
x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;32비트 운영체제의 경우는 대체로(?) 다음과 같이 표시 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;some description&amp;gt; i686 i686 i386 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;매킨토시:ff14a3c2d45e25c07d33525472b59348&#34;&gt;매킨토시&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Go언어&lt;/code&gt;의  &lt;a href=&#34;http://code.google.com/p/go/downloads/list&#34;&gt;다운로드 페이지&lt;/a&gt;로 이동 합니다.&lt;br /&gt;
&lt;code&gt;go1.x.x.darwin-amd64.pkg&lt;/code&gt; 파일을 선택해서 다운로드 하시기 바랍니다.(64비트 매킨토시의 경우)&lt;br /&gt;
다운로드 후, 탐색기(파인더)에서 더블 클릭하신 후 대부분 &amp;ldquo;다음&amp;rdquo; 버튼을 눌르시면 설치가 완료 됩니다.&lt;br /&gt;
매킨토시의 경우 &lt;code&gt;$PATH&lt;/code&gt; 환경변수를 자동으로 추가해 주게 됩니다. 터미널 프로그램을 실행하신 후&lt;br /&gt;
&lt;code&gt;go&lt;/code&gt; 명령을 입력하시면, 상기 그림1.1 과 같이 여러가지 정보가 표시 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;유닉스-리눅스:ff14a3c2d45e25c07d33525472b59348&#34;&gt;유닉스 / 리눅스&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Go언어&lt;/code&gt;의 &lt;a href=&#34;http://code.google.com/p/go/downloads/list&#34;&gt;다운로드 페이지&lt;/a&gt;로 이동 합니다.&lt;br /&gt;
&lt;code&gt;go1.*.*.linux-amd64.tar.gz&lt;/code&gt; 파일을 선택한 후 다운로드 합니다.(&lt;code&gt;64비트&lt;/code&gt;의 경우)&lt;br /&gt;
환경변수 &lt;code&gt;$GO_INSTALL_DIR&lt;/code&gt;을 설정하면 설정된 디렉토리에 설치되게 됩니다.&lt;br /&gt;
다운로드 후, 압축을 해제 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar xvzf go1.x.x.linux-amd64.tar.gz -C $GO_INSTALL_DIR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기와 같이 설정된 디렉토리에 압축을 해제 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=$PATH:$GO_INSTALL_DIR/go/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기의 명령과 같이 환경변수를 설정 합니다. (&lt;code&gt;.bashrc / .bash_profile&lt;/code&gt; 파일에 적용)&lt;br /&gt;
터미널 프로그램을 실행하신 후,  &lt;code&gt;go&lt;/code&gt; 명령을 입력하시면, 상기 그림1.1 과 같이 여러가지&lt;br /&gt;
정보가 표시 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;윈도우:ff14a3c2d45e25c07d33525472b59348&#34;&gt;윈도우&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Go언어&lt;/code&gt;의 &lt;a href=&#34;http://code.google.com/p/go/downloads/list&#34;&gt;다운로드 페이지&lt;/a&gt;로 이동 합니다.&lt;br /&gt;
&lt;code&gt;go1.*.*.windows-amd64.msi&lt;/code&gt; 파일을 선택한 후 다운로드 합니다.(&lt;code&gt;64비트&lt;/code&gt;의 경우)&lt;/p&gt;

&lt;p&gt;윈도우 탐색기로 다운로드한 파일을 더블클릭 하신 후 &amp;ldquo;다음&amp;rdquo; 버튼을 눌러서 설치를 완료 합니다.&lt;br /&gt;
&lt;code&gt;c:\go\bin&lt;/code&gt; 경로를 환경변수에 자동으로 추가하게 됩니다.&lt;br /&gt;
&lt;strong&gt;윈도우&lt;/strong&gt;의 경우에는 &lt;code&gt;윈도우키 + R&lt;/code&gt; 을 눌르신 후, &lt;code&gt;go&lt;/code&gt; 명령을 입력 합니다.&lt;br /&gt;
상기 그림1.1 과 같이 여러가지 정보가 표시 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;제-3자-설치-유틸리티로-설치:ff14a3c2d45e25c07d33525472b59348&#34;&gt;제 3자 설치 유틸리티로 설치&lt;/h2&gt;

&lt;h3 id=&#34;gvm:ff14a3c2d45e25c07d33525472b59348&#34;&gt;GVM&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;GVM&lt;/code&gt;은 Go언어를 여러가지 버전으로 설치해서 사용할 경우 사용하는 유틸리티 입니다.&lt;br /&gt;
사용하기 쉽다는 장점이 있습니다. gvm을 설치하신후 다음의 명령을 터미널에 입력해서 설치 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash &amp;lt; &amp;lt;(curl -s https://raw.github.com/moovweb/gvm/master/binscripts/gvm-installer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음으로 Go언어를 설치 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gvm install go1.0.3
gvm use go1.0.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;완료 되었다면, 모든 설정은 이미 완료된 것입니다. (환경변수 설정을 별도로 할 필요가 없습니다.)&lt;/p&gt;

&lt;h3 id=&#34;apt-get:ff14a3c2d45e25c07d33525472b59348&#34;&gt;apt-get&lt;/h3&gt;

&lt;p&gt;우분투 계열의 리눅스에서는 &lt;code&gt;apt-get&lt;/code&gt; 명령어로 대부분의 패키지를 설치할 수 있습니다.&lt;br /&gt;
다음의 명령을 입력하여 설치 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:gophers/go
sudo apt-get update
sudo apt-get install golang-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이상으로, 운영체제별로 &lt;code&gt;Go개발환경&lt;/code&gt;을 설치하는 것에 대해서 알아 보았습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [01/02] GOPATH &amp; Working Directory</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-01/02-gopath--working-directory</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-01/02-gopath--working-directory</guid>
      <description>

&lt;h1 id=&#34;gopath-및-작업-디렉토리:810b9d1b9c37d8356f62b59201217059&#34;&gt;$GOPATH 및 작업 디렉토리&lt;/h1&gt;

&lt;h2 id=&#34;gopath:810b9d1b9c37d8356f62b59201217059&#34;&gt;$GOPATH&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 명령어를 이용할 경우 대부분의 작업은 &lt;code&gt;$GOPATH&lt;/code&gt;라는 환경변수에 &lt;code&gt;절대적&lt;/code&gt;으로 의존하게 됩니다.&lt;br /&gt;
설치시 사용했었던, &lt;code&gt;$GOROOT&lt;/code&gt; 환경변수와는 별개로 작동하는 변수입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;개발자가 작성한 모든 패키지의 루트가 되는 디렉토리를 지정합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대부분의 경우 워크스페이스라고 부르는 프로젝트의 루트 디렉토리를 지정하는 것입니다.&lt;br /&gt;
유닉스 계열의 운영체제에서는 다음과 같이 설정합니다. (사용자는 xeno이며, 홈디렉토리의 mygo )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GOPATH=/home/xeno/mygo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;윈도우의 경우에는 별도로 &lt;code&gt;GOPATH&lt;/code&gt; 환경변수를 생성한 후 설정하여야 합니다.&lt;br /&gt;
&lt;code&gt;go get&lt;/code&gt; 명령을 사용해서 원격 저장소의 소스를 받아올때 &lt;code&gt;GOPATH&lt;/code&gt;에 설정된 디렉토리를 기준으로&lt;br /&gt;
작업하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$GOPATH&lt;/strong&gt; 디렉토리에는 &lt;code&gt;반드시&lt;/code&gt;` 다음과 같이 3개의 디렉토리가 존재해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;소스코드&lt;/code&gt;가 저장될 디렉토리 ( .go, .c, .g, .s &amp;hellip; )&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pkg&lt;/code&gt;&lt;br /&gt;
컴파일 후 &lt;code&gt;라이브러리 파일&lt;/code&gt;이저장될 디렉토리 ( .a &amp;hellip; )&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bin&lt;/code&gt;&lt;br /&gt;
빌드 후 &lt;code&gt;실행파일&lt;/code&gt;이 저장될 디렉토리 : go install 명령 사용 ( .exe &amp;hellip; )&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;본 가이드에서는 &lt;code&gt;mygo 디렉토리&lt;/code&gt;를 &lt;code&gt;GOPATH&lt;/code&gt;로 사용하게 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;패키지-디렉토리:810b9d1b9c37d8356f62b59201217059&#34;&gt;패키지 디렉토리&lt;/h3&gt;

&lt;p&gt;예를들어, &lt;code&gt;$GOPATH/src/mymath/sqrt.go&lt;/code&gt;라는 소스파일을 생성할 경우(mymath가 패키지이름)&lt;br /&gt;
패키지 이름과 디렉토리 명을 &lt;code&gt;통일&lt;/code&gt;` 시켜서 각각의 패키지들을 구분해서 사용하게 됩니다.&lt;/p&gt;

&lt;p&gt;대형 프로젝트나 외부에 노출할 패키지의 경우에는 다중 경로명을 사용해서 패키지를 구별할 수 있습니다.&lt;br /&gt;
&lt;code&gt;github.com/xenostream/mymath&lt;/code&gt;와 같은 경우가 그예입니다. (각각의 이름은 디렉토리 이름입니다.)&lt;/p&gt;

&lt;p&gt;상기와 같이 패키지를 저장 했다면, 다음과 같이 디렉토리를 생성 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $GOPATH/src
mkdir -p github.com/xenostream/mymath
cd $GOPATH/src/github.com/xenostream/mymath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sqrt.go 라는 파일을 생성한 후 다음과 같이 입력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Source code of $GOPATH/src/github.com/xenostream/mymath/sqrt.go
package mymath

func Sqrt(x float64) float64 {
    z := 0.0
    for i := 0; i &amp;lt; 1000; i++ {
        z -= (z*z - x) / (2 * x)
    }
    return z
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;강제사항은 아니지만, 최대한 패키지이름의 디렉토리를 생성해서 사용하시기 바랍니다.&lt;br /&gt;
해당 패키지에 연관된 소스를 한데모아서 사용하는 것이 &lt;code&gt;패키지&lt;/code&gt;` 입니다.&lt;/p&gt;

&lt;h3 id=&#34;패키지-컴파일:810b9d1b9c37d8356f62b59201217059&#34;&gt;패키지 컴파일&lt;/h3&gt;

&lt;p&gt;상기의 명령을 통해서 패키지를 이미 생성했습니다.  이제 소스파일을 컴파일하는 것에 대해서&lt;br /&gt;
설명 합니다. 컴파일하는 방법은 대체로 다음과 같이 두가지 방법이 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;컴파일 할 소스 디렉토리로 이동 한 후 &lt;code&gt;go install&lt;/code&gt; 명령으로 컴파일&lt;/li&gt;
&lt;li&gt;상기 명령에서 확장자를 뺀, 패키지명으로 컴파일 &lt;code&gt;go install mymath&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;상기의 예제코드에는
&amp;gt; &lt;code&gt;main 패키지&lt;/code&gt;가 없으므로, 라이브러리 패키지 입니다.&lt;/p&gt;

&lt;p&gt;그래서 다음과같은 디렉토리에 해당 결과물이 생성 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$GOPATH/pkg/${GOOS}_${GOARCH}
mymath.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;.a&lt;/strong&gt; 확장자의 의미는 바이너리 패키지를 의미 합니다.&lt;br /&gt;
이제 생성한 라이브러리 패키지를 사용 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $GOPATH/src
mkdir mathapp
cd mathapp
vi main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기 명령으로 mymath 패키지를 실제로 사용할 프로그램을 작성하는 것입니다.&lt;br /&gt;
다음과 같이 코드를 입력 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//$GOPATH/src/mathapp/main.go 
package main

import (
    &amp;quot;mymath&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func main() {
    fmt.Printf(&amp;quot;Hello, world. Sqrt(2) = %v\n&amp;quot;, mymath.Sqrt(2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이미 설명했던 컴파일 방법으로(&lt;code&gt;cd $GOPATH/src/mathapp; go install&lt;/code&gt;) 프로그램을 컴파일 합니다.&lt;br /&gt;
main 함수를 가지고 있는 main 패키지이므로 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 디렉토리에 결과물이 생성 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $GOPATH/bin
./mathapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기의 명령으로 작성한 프로그램을 컴파일 한 후 실행 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello world. Sqrt(2) = 1.414213562373095
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;원격-패키지-설치:810b9d1b9c37d8356f62b59201217059&#34;&gt;원격 패키지 설치&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Go언어&lt;/code&gt;는 원격 패키지를 설치할 수 있는 기능을 제공 합니다. &lt;code&gt;go get&lt;/code&gt; 명령을 이용하면, 여러가지&lt;br /&gt;
원격 저장소에 저장된 패키지를 가져와서 사용할 수 있게 됩니다.&lt;br /&gt;
&lt;code&gt;GitHub, Google Code, BitBurket, Launchpad&lt;/code&gt; 등&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/xenostream/mymath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기와 같이 명령하면 해당 패키지를 &lt;code&gt;$GOPATH/src&lt;/code&gt; 디렉토리 밑에 디렉토리 구조를 유지한 채 가져 옵니다.&lt;br /&gt;
&lt;code&gt;go get -u 패키지이름&lt;/code&gt;` 과 같이 사용할 경우 최신버전으로 업데이트 하게 됩니다.  또한, 패키지 내부에서&lt;br /&gt;
사용하는 또다른 패키지 또한 함께 가져오게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$GOPATH
    src
     |-github.com
          |-xenostream
               |-mymath
    pkg
     |--${GOOS}_${GOARCH}
          |-github.com
               |-xenostream
                    |-mymath.a

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go get&lt;/code&gt; 명령을 사용하면 상기와 같은 구조로 생성 됩니다.  사실 원격패키지의 &lt;code&gt;복사본&lt;/code&gt;을 가져오게 됩니다.&lt;br /&gt;
이미 말씀드렸듯이, &lt;code&gt;$GOPATH/src&lt;/code&gt; 디렉토리 밑에 생성 됩니다.&lt;/p&gt;

&lt;p&gt;상기와 같이 원격 패키지를 가져왔다면, 사용을 하려는 소스에서 다음과 같이 선언해서 사용 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;github.com/xenostream/mymath
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;최종-디렉토리-구조:810b9d1b9c37d8356f62b59201217059&#34;&gt;최종 디렉토리 구조&lt;/h3&gt;

&lt;p&gt;지금까지의 명령어와 스텝을 수행 했다면 다음과 같은 디렉토리 구조를 가지게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/
    mathapp
pkg/
    ${GOOS}_${GOARCH} 예)darwin_amd64, linux_amd64
  mymath.a
  github.com/
    xenostream/
      mymath.a
src/
    mathapp
        main.go
    github.com/
        xenostream/
            mymath/
                sqrt.go

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bin&lt;/strong&gt;디렉토리에 실행파일이 생성되고, &lt;strong&gt;src&lt;/strong&gt;디렉토리에 소스가 저장되며, &lt;strong&gt;pkg&lt;/strong&gt;디렉토리에&lt;br /&gt;
컴파일된 라이브러리가 존재한다고 생각하시면 됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [01/03] GO Command</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-01/03-go-command</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-01/03-go-command</guid>
      <description>

&lt;h1 id=&#34;go-command:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;Go Command&lt;/h1&gt;

&lt;h2 id=&#34;go-명령어:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;Go 명령어&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go 언어&lt;/code&gt;는 명령어로만 모든 작업을 할 수 있는 환경을 제공 합니다.&lt;br /&gt;
바로, &lt;code&gt;go&lt;/code&gt; 명령어로 수행합니다. 명령창에서 &lt;em&gt;go&lt;/em&gt; 명령을 입력하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/1_3_go.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
 &amp;lt;그림 1. 3&amp;gt; go 명령어 화면&lt;/p&gt;

&lt;h2 id=&#34;go-build:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go build&lt;/h2&gt;

&lt;p&gt;컴파일 타입 언어의 컴파일 명령에 속합니다. 연관된 패키지가 있다면 같이 컴파일 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.2절에서 보았듯이 &lt;code&gt;main&lt;/code&gt; 패키지가 존재하지 않는다면, *go build*명령어를 사용해도&lt;br /&gt;
실행파일을 생성하지 않습니다. (라이브러리 패키지)&lt;br /&gt;
&lt;code&gt;$GOPATH/pkg&lt;/code&gt; 디렉토리에 컴파일된 라이브러리 파일을 만들려면 &lt;code&gt;go install&lt;/code&gt;명령을&lt;br /&gt;
사용하시기 바랍니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;main&lt;/code&gt;패키지를 가지고 있다면,(응용프로그램 패키지) 현재 디렉토리에 실행파일을 생성하게 됩니다.&lt;br /&gt;
&lt;code&gt;$GOPATH/bin&lt;/code&gt; 디렉토리에 실행파일을 생성하기 원한다면, &lt;code&gt;go install&lt;/code&gt; 또는&lt;br /&gt;
&lt;code&gt;go build -o ${PATH}/a.exe&lt;/code&gt;와 같이 원하는 파일을 지정하면 됩니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;현재 디렉토리에 많은 소스파일이 존재한다면, 컴파일을 원하는 파일명을 지정하면 됩니다.&lt;br /&gt;
예를들어 *a.go*파일만을 컴파일 하려면, &lt;code&gt;go build a.go&lt;/code&gt; 라는 명령을 수행하시기 바랍니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;컴파일할때 실행 파일이름을 지정할 수 있습니다. 예를 들어서, *mathapp*프로그램의 결과 파일을&lt;br /&gt;
&lt;strong&gt;xeno.exe&lt;/strong&gt;로 지정하기 위해서는 다음과 같이 명령합니다. &lt;code&gt;go build -o xeno.exe&lt;/code&gt;&lt;br /&gt;
기본적으로 생성하는 실행파일 이름은 디렉토리 이름으로 생성됩니다. (main패키지가 포함된&amp;hellip;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;go build&lt;/code&gt; 명령으로 컴파일 할 경우 &lt;code&gt;_ (언더바) 또는 . (점)&lt;/code&gt;으로 시작하는 파일은 컴파일에서 제외합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;만약, 운영체제별로 그에 맞는 파일만 컴파일 할 경우에는, &lt;code&gt;array_&lt;/code&gt;라는 접두어로 파일명을 지정해서&lt;br /&gt;
처리합니다.(예: &lt;code&gt;array_linux.go | array_darwin.go | array_windows.go&lt;/code&gt;)&lt;br /&gt;
현재 운영체제가 리눅스일 경우에는 &lt;em&gt;array_linux.go&lt;/em&gt; 파일만 컴파일 하게 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-clean:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go clean&lt;/h2&gt;

&lt;p&gt;컴파일러가 컴파일 할 때 생성했던 모든 파일을 제거하는 작업 입니다. 컴파일 시에 생성되는 파일에는&lt;br /&gt;
다음과 같은 파일이 존재할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_obj
_test/
_testmain.go
test.out
build.out
*.[568ao]
DIR(.exe)
DIR.test(.exe)
MAINFILE(.exe)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;GitHub.Com&lt;/code&gt;에 소스를 올리기 &lt;strong&gt;직전에 수행하여&lt;/strong&gt;, 필요한 파일만 업로드할 경우에 주로 사용 합니다.&lt;/p&gt;

&lt;h2 id=&#34;go-fmt-gofmt:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go fmt / gofmt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;C/C++/Java&lt;/code&gt;와 같은 언어에서의 항상 고민되는 문제는 &lt;code&gt;코딩스타일&lt;/code&gt;이 사람마다 다르기 때문에, 다른사람이&lt;br /&gt;
작성한 소스코드를 읽을 경우 읽기가 힘들다는 문제가 발생하는 것입니다. (&lt;code&gt;KR&amp;amp;C / ANSI-C ...&lt;/code&gt;)&lt;br /&gt;
하지만, &lt;strong&gt;Go&lt;/strong&gt;언어에서는 이러한 문제가 발생하지 않습니다. &lt;code&gt;한가지 코딩스타일&lt;/code&gt;만 존재하고 &lt;strong&gt;강제적&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;예를 들어서,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;여는 중괄호(&lt;code&gt;{&lt;/code&gt;)는 반드시 문장의 끝에서만 열어야만 합니다.&lt;br /&gt;
이것은 강제적입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 코딩 규칙을 별도로 배둘 필요는 없습니다. 바로 &lt;code&gt;go fmt&lt;/code&gt;명령이 존재하기 때문입니다.&lt;br /&gt;
&lt;strong&gt;go fmt&lt;/strong&gt;명령은 소스코드를 *go*언어의 코딩스타일에 맞도록 자동으로 소스코드를 정렬해 주는 명령입니다.&lt;/p&gt;

&lt;p&gt;하지만, 이 명령을 별도로 수행하는 경우는 자주 없습니다. &lt;strong&gt;Go IDE&lt;/strong&gt;들에서 이것을 자동으로 처리하기&lt;br /&gt;
때문입니다. 대부분의 경우 소스코드를 컴파일 하거나, 저장할 경우에 자동으로 *go fmt*명령을 수행 합니다.&lt;/p&gt;

&lt;p&gt;실제로 &lt;code&gt;go fmt&lt;/code&gt;명령은 &lt;code&gt;gofmt&lt;/code&gt; 명령 파일의 대체이름일 뿐 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gofmt -w &amp;lt;소스파일명&amp;gt;&lt;/code&gt; 옵션은 정렬한 소스코드를 현재 소스코드에 곧바로 적용할 때 사용 합니다.&lt;/p&gt;

&lt;h2 id=&#34;go-get:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go get&lt;/h2&gt;

&lt;p&gt;이 명령은 &lt;code&gt;원격저장소&lt;/code&gt;에 저장된 소스코드를 가져오는 명령 입니다. &lt;code&gt;BitBucket, Github, Google Code&lt;/code&gt;등의&lt;br /&gt;
현재 유용하게 사용하는 원격저장소 서비스에 접속해서 해당하는 패키지의 소스를 가져오게 됩니다.&lt;br /&gt;
이 명령은 실제로는 두가지 작업으로 처리되게 됩니다. 첫 번째는 먼저 소스코드를 다운로드 합니다.&lt;br /&gt;
그리고 다운로드 받은 소스코드를 &lt;code&gt;go install&lt;/code&gt;명령을 호출해서 현재 시스템에 설치하는 작업을 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go help remote&lt;/code&gt; 명령을 통해서 현재 지원되는 원격저장소에 관련된 도움말을 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;go-install:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go install&lt;/h2&gt;

&lt;p&gt;소스코드를 컴파일 하고, 패키지가 생성하는 중요한 파일을 &lt;code&gt;$GOPATH/pkg 또는 $GOPATH/bin&lt;/code&gt; 디렉토리에&lt;br /&gt;
복사한 후 &lt;code&gt;설치&lt;/code&gt;하는 명령어 입니다.&lt;/p&gt;

&lt;h2 id=&#34;go-test:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go test&lt;/h2&gt;

&lt;p&gt;이 명령은 &lt;code&gt;*-test.go&lt;/code&gt; 형식으로 사용하며, 테스트용 파일로 생성하며 다음과 같이 실행 정보를 표시 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ok   archive/tar     0.011s
FAIL archive/tar     0.02s
ok   compress/gzip   0.033s
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go help testflag&lt;/code&gt; 명령을 통해서 보다 자세한 사항을 살펴 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;go-doc:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;go doc&lt;/h2&gt;

&lt;p&gt;대부분의 개발자들은 별도의 도움말 및 문서화 시스템을 사용하는 것을 원하지 않습니다. 개발 환경에서 자체적으로&lt;br /&gt;
제공하기를 바랍니다.(Java의 javadoc) *Go*언어에서는 &lt;code&gt;기본적&lt;/code&gt;으로 문서화 기능을 제공 합니다.&lt;/p&gt;

&lt;p&gt;*Go*언어에서 기본적으로 제공하는 패키지에 대하여 문서를 생성하려면, &lt;code&gt;godoc builtin&lt;/code&gt;명령 형식으로&lt;br /&gt;
사용하면 됩니다. 예를 들어, &lt;code&gt;net/http&lt;/code&gt; 패키지에 대한 문서는 &lt;code&gt;godoc net/http&lt;/code&gt;명령을 사용 합니다.&lt;br /&gt;
또한, &lt;code&gt;fmt.Printf&lt;/code&gt; 함수에 대한 문서를 보려면 &lt;code&gt;godoc fmt Printf&lt;/code&gt;와 같이 사용 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;godoc -http=:8080&lt;/code&gt;명령을 사용하면, 웹 브라우저를 열고 &lt;code&gt;http://127.0.0.1:8080&lt;/code&gt;주소를&lt;br /&gt;
입력해서 웹 브라우저에서 내용을 살펴볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;etc:3cf30c7269ed4c90ef7f8fc7648b5359&#34;&gt;Etc&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;go&lt;/code&gt;에서는 다음과 같은 명령들도 제공 합니다. &lt;code&gt;go help &amp;lt;명령어&amp;gt;&lt;/code&gt; 형식으로 직접 알아보시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go fix       구버전에서 작성한 소스를 현재 버전으로 업그레이드 합니다.
go version   현재 설치된 Go언어의 버전 정보를 표시 합니다.
go env       현재 Go언어에서 사용하는 여러가지 환경변수를 표시합니다.(GOOS, GOROOT, GOPATH...)
go list      현재 시스템에 설치된 패키지를 표시 합니다. 
go run       실행파일을 생성하지 않고 곧바로 소스를 컴파일하고 실행 합니다. 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [01/04] Go Developement Tools</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-01/04-go-developement-tools</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-01/04-go-developement-tools</guid>
      <description>

&lt;h1 id=&#34;go-development-tools:047ca95d26a512c102e582ec0b4e5483&#34;&gt;Go Development Tools&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [01/05] Summary</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-01/05-summary</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-01/05-summary</guid>
      <description>

&lt;h1 id=&#34;01-summary:54ebe95fa4ade3ffbf480821fcf69654&#34;&gt;01_Summary&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/00] Basic Knowledge</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/00-basic-knowledge</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/00-basic-knowledge</guid>
      <description>

&lt;h1 id=&#34;basic-knowledge:b1a10aa99bc2afeeef478938b0341311&#34;&gt;Basic Knowledge&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 언어는 C언어를 매우 닮은 시스템 프로그래밍이 가능한 &lt;code&gt;컴파일형&lt;/code&gt; 언어 입니다. 컴파일 속도가 C언어보다&lt;br /&gt;
빠르며, 언어에서 사용하는  키워드도 겨우 25개뿐 입니다. 알파벳 숫자보다 적으며, 매우 간단한 구조로 되어 있습니다.&lt;/p&gt;

&lt;p&gt;우선 어떤 키워드가 있는지 살펴 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;break    default     func   interface select
case     defer       go     map       struct
chan     else        goto   package   switch
const    fallthrough if     range     type
continue for         import return    var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번 장에서는 &lt;code&gt;Go&lt;/code&gt;언어의 기초적인 부분에 대하여 설명 합니다. 각 장을 통해서 &lt;code&gt;Go 언어&lt;/code&gt;가 얼마나 간결하고&lt;br /&gt;
정교하게 디자인되어 있는지를 아시게 될 것입니다. &lt;code&gt;Go&lt;/code&gt;를 이용해서 프로그램을 작성하는 것은 매우 즐거운 일입니다.&lt;/p&gt;

&lt;p&gt;이 장을 다 읽은 후에는 이 25개의 키워드가 더욱 친숙해 질 것입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/01] Hello, Go!!</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/01-hello-go</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/01-hello-go</guid>
      <description>

&lt;h1 id=&#34;hello-go:26559df69bf5bb9f9eb0a79259c4e843&#34;&gt;Hello, Go!!&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;언어를 이용해서 응용 프로그램을 작성하기 전에 먼저 기본이되는 프로그램으로 시작 하도록 하겠습니다.&lt;br /&gt;
집을 짓기 전에 건물의 기초를 알아야 하듯이, 프로그램을 작성하는 것도 기본적인 것부터 시작해야 합니다.&lt;br /&gt;
본 장에서는, 가장 기본적인 문법을 학습하고 Go 프로그램을 작성하고 실행하는 것에 대해서 알아 보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;program:26559df69bf5bb9f9eb0a79259c4e843&#34;&gt;Program&lt;/h2&gt;

&lt;p&gt;다음은 &lt;code&gt;전통적인&lt;/code&gt;것으로서 대부분의 언어를 학습 할 때 화면에 &lt;code&gt;hello world&lt;/code&gt;를 출력하는 프로그램을&lt;br /&gt;
작성하는 것으로 프로그래밍을 시작하게 됩니다.&lt;/p&gt;

&lt;p&gt;준비 되셨나요? 시작하겠습니다!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main () {
    fmt.Printf(&amp;quot;Hello, world or 你好 세계 or καλημ ρα κóσμ or 안녕하세요 \n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;입력한 후 실행하면 다음과 같이 출력됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, world or 你好 세계 or καλημ ρα κóσμ or 안녕하세요
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;설명:26559df69bf5bb9f9eb0a79259c4e843&#34;&gt;설명&lt;/h2&gt;

&lt;p&gt;우리는 먼저 개념을 이해할 필요가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Go 프로그램은 모든것이 &lt;code&gt;package&lt;/code&gt;로 구성되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;package &amp;lt;pkgName&amp;gt;&lt;/code&gt;(예제에서는 &lt;code&gt;package main&lt;/code&gt;)이 한 줄이 현재 파일이 어떤 패키지에&lt;br /&gt;
속해 있는지를 나타냅니다. 또한 &lt;code&gt;main&lt;/code&gt; 패키지는 바로 독립적으로 실행 할 수 있는 패키지임을 보여&lt;br /&gt;
줍니다. 컴파일 과정을 거치면  실행 파일이 생성 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 패키지가 아닌 다른 패키지일 경우에는 컴파일 과정 후에 &lt;code&gt;* .a&lt;/code&gt;라는 파일이 생성 됩니다.&lt;br /&gt;
(&lt;code&gt;패키지 파일&lt;/code&gt;이라고도 합니다.) &lt;code&gt;$GOPATH/pkg/$GOOS_$GOARCH&lt;/code&gt; 경로에 생성 됩니다.&lt;br /&gt;
(Mac에서는 &lt;code&gt;$GOPATH/pkg/darwin_amd64&lt;/code&gt;에 생성 됩니다.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;독립적으로 실행 할 수있는 Go 프로그램은,&lt;br /&gt;
반드시&lt;code&gt;package main&lt;/code&gt;으로 시작 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또한, 독립실행 패키지의 &lt;code&gt;main&lt;/code&gt; 패키지에는 &lt;strong&gt;반드시&lt;/strong&gt; &lt;code&gt;main&lt;/code&gt; 함수가 포함되어 있습니다.&lt;br /&gt;
이 &lt;code&gt;main()&lt;/code&gt; 함수는 &lt;code&gt;인수가없고, 반환 값 또한 없는 구조&lt;/code&gt;로 되어 있습니다. (&lt;code&gt;main.main()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hello, world ...&lt;/code&gt;와 같은 문자열을 화면에 출력하기 위해서, &lt;code&gt;Printf()&lt;/code&gt; 함수를 사용 합니다.&lt;br /&gt;
이 함수는 &lt;code&gt;fmt&lt;/code&gt; 패키지에 포함되어 있기 때문에, 시스템에서 기본적으로 제공하는 &lt;code&gt;fmt&lt;/code&gt; 패키지를 임포트하고&lt;br /&gt;
있습니다. (예제의 경우 &lt;code&gt;import &amp;quot;fmt&amp;quot;&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;패키지는 Python의 package와 비슷 합니다. 패키지를 사용하면 특별한 장점이 있습니다. 그것은 바로,&lt;br /&gt;
&lt;code&gt;모듈화&lt;/code&gt;(프로그램을 여러 모듈로 분할)와 &lt;code&gt;재사용성&lt;/code&gt;(각 모듈은 다른 프로그램에서 재사용) 입니다.&lt;/p&gt;

&lt;p&gt;지금은 패키지의 개념을 이해하는 것으로 그치고, 자세한 내용은 &lt;code&gt;패키지&lt;/code&gt;를 설명하는장에서 설명 합니다.&lt;/p&gt;

&lt;p&gt;다섯번째 줄은 키워드 &lt;code&gt;func&lt;/code&gt;를 통해 &lt;code&gt;main()&lt;/code&gt; 함수를 &lt;strong&gt;정의&lt;/strong&gt;하고 있습니다.&lt;br /&gt;
함수의 내용은 &lt;code&gt;{ ... }&lt;/code&gt; 안에 기록 합니다. 이런 방식은 &lt;code&gt;C/C++, Java&lt;/code&gt;언어와 동일 합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;main()&lt;/code&gt; 함수는 아무런 인수도 없고 반환값도 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;뒷장에서 인자와, 0개 이상의 값을 반환하는 함수를 사용하는 방법에 대해서 학습하게 됩니다.&lt;/p&gt;

&lt;p&gt;여섯번째 줄에서는 &lt;code&gt;fmt&lt;/code&gt; 패키지에 정의 된 &lt;code&gt;Printf()&lt;/code&gt; 함수를 호출 합니다.&lt;br /&gt;
이렇듯 함수는 &lt;code&gt;&amp;lt;pkgName&amp;gt;.&amp;lt;funcName&amp;gt;&lt;/code&gt;형식으로 호출합니다. 이 점은 Python과 비슷 합니다.&lt;/p&gt;

&lt;p&gt;1장에서 알아본것과 같이, 패키지 이름과 실제로 패키지가 존재하는 디렉토리의 이름이 달라도 상관 없습니다.&lt;br /&gt;
예제에서 말하는 &lt;code&gt;&amp;lt;pkgName&amp;gt;&lt;/code&gt;이 실제 디렉토리 이름이 아닐 수 있습니다.  단지 &lt;code&gt;package &amp;lt;pkgName&amp;gt;&lt;/code&gt;으로&lt;br /&gt;
선언 된 패키지 이름에 불과 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 우리가 출력 한 내용을 유심히 살펴보시면 &lt;code&gt;ASCII&lt;/code&gt;코드가 아닌 문자가 많이, 포함 되어있는 것을 알 수&lt;br /&gt;
있습니다. 실제로 &lt;code&gt;Go 언어&lt;/code&gt;는  &lt;strong&gt;UTF-8&lt;/strong&gt;을 기본적으로 지원하고 있으며, 어떤 문자든지 직접 출력 할 수 있습니다.&lt;br /&gt;
당연히, UTF-8 문자를 식별자로 사용해도 오류가 발생하지 않습니다. (권장하지는 않습니다!!)&lt;/p&gt;

&lt;h2 id=&#34;결론:26559df69bf5bb9f9eb0a79259c4e843&#34;&gt;결론&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Go언어는 &lt;code&gt;package&lt;/code&gt;를 사용하여 코드를 구성 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;main.main()&lt;/code&gt; 함수는 현재 파일이 &lt;code&gt;실행 파일&lt;/code&gt;임을 의미 합니다.&lt;/p&gt;

&lt;p&gt;Go언어는 기본적으로 UTF-8 문자열과 식별자를 사용하기 때문에, 언어차원에서 다국어를 지원하고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/02] Go Foundation</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/02-go-foundation</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/02-go-foundation</guid>
      <description>

&lt;h1 id=&#34;go-foundation:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;Go Foundation&lt;/h1&gt;

&lt;p&gt;이 장에서는 변수, 상수, 기본타입과 Go 프로그램의 여러가지 기본적인 기법에 대해서 소개 합니다.&lt;/p&gt;

&lt;h2 id=&#34;변수:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;변수&lt;/h2&gt;

&lt;p&gt;Go 언어에서 변수는 여러가지 방법으로 선언될 수 있습니다. 가장 표준적인 방법인&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 변수를 선언하는 방법 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;C 언어&lt;/code&gt;와 달리 Go언어는&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;변수의 유형을 &lt;strong&gt;변수 뒤&lt;/strong&gt;에 놓습니다!!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  // &amp;quot;variableName&amp;quot;라는 이름의 변수를 선언 합니다. 변수 형식은 &amp;quot;type&amp;quot;입니다.   
  var variableName type  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러 변수를 한번에 선언 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  // &amp;quot;type&amp;quot;형의 변수 3개를 선언 합니다.
  var vname1, vname2, vname3 type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;변수를 선언함과 동시에 초기화 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  // &amp;quot;variableName&amp;quot;변수를 &amp;quot;value&amp;quot;로 초기화합니다. 형식은 &amp;quot;type&amp;quot;입니다.
  var variableName type = value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러개의 변수를 동시에 선언한 후 초기화 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
  모든 변수를 &amp;quot;type&amp;quot;형으로 선언하고,vname1은 v1, vname2는 v2, vname3은 v3으로 초기화 합니다. 
*/
  var vname1, vname2, vname3 type = v1, v2, v3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 위와 같은 방식으로 변수를 선언하는 방식이 불편하다고 생각 하십니까?&lt;br /&gt;
이런 문제점은, Go 언어의 설계자도 이미 알고 있습니다. 좀 더 쉽게 변수를 선언할 수 있는 방법이 있습니다.&lt;br /&gt;
초기값으로 해당변수의 형식을 판가름 할 수 있으므로, 다음과 같은 방법으로 변수를 선언할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
   3 개의 변수를 선언하고 개별적으로 초기화 합니다. 
   vname1는 v1, vname2는 v2, vname3는 v3 과 같이 대입되는 값의 형식에 맞게 각각의   
   형(타입)이 정해지고 초기화 됩니다.
*/
   var vname1, vname2, vname3 = v1, v2, v3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이런 방법도 여전히 번거로우신가요?&lt;br /&gt;
좀 더 나은 방법으로 선언해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
  3개의 변수를 선언하고 개별적으로 초기화 합니다.
  vname1는 v1, vname2는 v2, vname3는 v3
  컴파일러는 초기화 값에 따라 자동으로 적합한 형식을 판단 합니다.   
*/
  vname1, vname2, vname3 :=  v1, v2, v3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법이면 매우 간결하게 사용 할 수 있겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;:=&lt;/code&gt;기호가 &lt;code&gt;var&lt;/code&gt;와&lt;code&gt;type&lt;/code&gt;을 대체 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 형식으로 변수를 선언하는 것을 &lt;code&gt;단축선언&lt;/code&gt;이라고 합니다. 그러나 이 단축선언 방식에는 한가지 제한이&lt;br /&gt;
있습니다. 바로 &lt;code&gt;함수 내부&lt;/code&gt;에서만 사용할 수 있습니다. 만약 함수 밖에서 사용하면 컴파일러가 에러를 출력 합니다.&lt;br /&gt;
이말은 곧 일반적으로 &lt;code&gt;var&lt;/code&gt; 형식으로 선언하는 변수들은 &lt;code&gt;글로벌 변수&lt;/code&gt;로 선언된다는 의미 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_&lt;/code&gt; (밑줄)은 변수의 &lt;strong&gt;특별한&lt;/strong&gt; 이름 입니다. 어떤 값으로 초기화를 해도 그 값을 모두 버려 버립니다.&lt;br /&gt;
다음의 경우, &lt;code&gt;35&lt;/code&gt;라는 값을 &lt;code&gt;b&lt;/code&gt;에 부여하며, &lt;code&gt;34&lt;/code&gt;는 &lt;strong&gt;버려&lt;/strong&gt; 버립니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ , b := 34, 35
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 컴파일러에서는,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;선언한 후 사용하지 않는 변수가 발견되면
컴파일 오류&lt;/strong&gt;를 출력 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 다음과 같은 코드는 에러 입니다. 그래서 &lt;code&gt;밑줄 변수&lt;/code&gt;가 존재하는 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main () {
    var i int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;상수:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;상수&lt;/h2&gt;

&lt;p&gt;이른바 &lt;code&gt;상수&lt;/code&gt;는 프로그램이 &lt;code&gt;컴파일되는 단계&lt;/code&gt;에서 값이 결정되며, 프로그램이 실행되면 값을 절대 변경할 수&lt;br /&gt;
없습니다. 이와같은 상수는 &lt;code&gt;숫자, bool 또는 문자열&lt;/code&gt;등의 값을 사용해서 선언 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;상수로 선언하는 문법은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const constantName = value
    // 만약 필요하다면 상수의 타입을 명시적으로 표시 할 수 있습니다.  
const Pi float32 = 3.1415926
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 여러가지 상수 선언의 예제 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const Pi = 3.1415926
const i = 10000
const MaxThread = 10
const prefix = &amp;quot;astaxie_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 상수는 일반적인 프로그래밍 언어와 달리 더욱 정밀한 소수점을 지정할 수 있습니다.(예: 소수점 200 자리 등)&lt;/p&gt;

&lt;h2 id=&#34;내장-기본형:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;내장 기본형&lt;/h2&gt;

&lt;h3 id=&#34;boolean:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;Boolean&lt;/h3&gt;

&lt;p&gt;Go언어에서 bool값의 선언 키워드는 &lt;code&gt;bool&lt;/code&gt;입니다. 값은&lt;code&gt;true&lt;/code&gt; 혹은&lt;code&gt;false&lt;/code&gt;이며, 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var isActive bool                    // 전역 변수 선언
var enabled, disabled = true, false  // 형 생략 선언
func test () {
    var available bool               // 일반 선언
    valid := false                   // 단축 선언
    available = true                 // 대입 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;숫자:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;숫자&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;정수&lt;/code&gt;에는 부호와 무부호의 2가지가 있습니다. Go에서는 &lt;code&gt;int&lt;/code&gt;와 &lt;code&gt;uint&lt;/code&gt;로 지원하고 있습니다.&lt;br /&gt;
이 두 타입은 길이는 비록 같지만, 32/64비트 운영체제에 따라 실제 길이는 다르게 표현 됩니다.&lt;/p&gt;

&lt;p&gt;Go에서는 다음과 같이 직접 bit 수를 지정할 수있는 유형도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;rune int8 int16 int32 int64 byte uint8 uint16 uint32 uint64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rune&lt;/code&gt;은 &lt;code&gt;int32&lt;/code&gt;의 별칭이며, UTF-8 한 문자를 저장 합니다.&lt;br /&gt;
&lt;code&gt;byte&lt;/code&gt;는 &lt;code&gt;uint8&lt;/code&gt;의 별칭이며, ASCII한 문자를 저장 합니다.&lt;/p&gt;

&lt;p&gt;주의해야 할 점은 한번 형태를 지정하면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;다른 형식의 변수끼리 연산을 할 수 없으며,
연산시에는 오류를 발생 시킵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 다음의 코드는 오류가 발생합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; var a int8
 var b int32
 c := a + b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;invalid operation : a + b (mismatched types int8 and int32)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;32비트 운영체제에서 int의 길이는 32bit지만, int 및 int32도 서로 연산할 수 없습니다.(강타입 언어)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;부동 소수점&lt;/code&gt; 형식은 &lt;code&gt;float32&lt;/code&gt;와 &lt;code&gt;float64&lt;/code&gt;의 두 종류만 있습니다 (&lt;code&gt;float&lt;/code&gt; 형은 없습니다.)&lt;br /&gt;
디폴트는 &lt;code&gt;float64&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;이것이 숫자의 모든것은 아닙니다. 공학도들에게 친숙한 복소수 또한 Go에서는 지원하고 있습니다.&lt;br /&gt;
기본 형식은 &lt;code&gt;complex128&lt;/code&gt;(64bit 실수 + 64bit 허수)입니다. 만약 좀 더 작은 값이 필요하다면,&lt;br /&gt;
&lt;code&gt;complex64&lt;/code&gt;(32bit 실수 + 32bit 허수)도 있습니다.&lt;br /&gt;
복소수의 형식은 &lt;code&gt;RE + IMi&lt;/code&gt; 입니다. 이 중 &lt;code&gt;RE&lt;/code&gt;가 실수 부분 &lt;code&gt;IM&lt;/code&gt;이  허수 부분이며,&lt;br /&gt;
마지막&lt;code&gt;i&lt;/code&gt;는 허수 단위 입니다. 다음은 복소수 사용 예제 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c complex64 = 5 + 5i
fmt.Printf(&amp;quot;Value is : % v&amp;quot;, c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Value is : (5 + 5i)&lt;/code&gt; 와 같이 출력 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;문자열:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;문자열&lt;/h3&gt;

&lt;p&gt;앞 장에서 언급 한 바와 같이 Go언어에서 문자열은 모두 &lt;code&gt;UTF-8&lt;/code&gt; 코드로 사용 합니다.&lt;br /&gt;
문자열은 쌍 따옴표(&amp;ldquo;&amp;rdquo;) 또는 백틱(&amp;ldquo;)으로 감싸는 것으로 선언 됩니다. (&amp;ldquo;string&amp;rdquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var frenchHello string      // 문자열 변수 선언의 일반적인 방법
var emptyString string = &amp;quot;&amp;quot; // 문자열 변수를 하나 선언하고 빈 문자열로 초기화 한다.
func test() {
    no, yes maybe := &amp;quot;no&amp;quot; &amp;quot;yes&amp;quot; &amp;quot;maybe&amp;quot;   // 단축선언, 동시에 여러 변수를 선언 및 초기화    
    japaneseHello := &amp;quot;Konichiwa&amp;quot;          // 선언 및 초기화
    frenchHello = &amp;quot;Bonjour&amp;quot;               // 문자열 대입
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Go 언어에서 문자열은 절대 변경할 수 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를들어 다음 코드는 컴파일시 오류가 발생 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s string = &amp;quot;hello&amp;quot;
s [0] = &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;오류내용 : &lt;code&gt;can not assign to s [0]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만, 프로그래밍 중에 실제로 문자열 값을 바꿀려면 다음과 같이 사용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := &amp;quot;hello&amp;quot;
c := []byte(s)        // 문자열 s를 []byte 형 배열로 변환
c [0] = &#39;c&#39;           // 배열 인덱스로 값 변경 
s2 := string(c)       // 배열을 다시 string 형식으로 변환 
fmt.Printf( &amp;quot;%s \n&amp;quot;, s2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go는 &lt;code&gt;+&lt;/code&gt; 연산자를 사용하여 문자열을 연결할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := &amp;quot;hello&amp;quot;
m := &amp;quot;world&amp;quot;
a := s + m
fmt.Printf ( &amp;quot;%s \n&amp;quot;, a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;문자열을 수정할 경우 이런 방법도 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := &amp;quot;hello&amp;quot;
s = &amp;quot;c&amp;quot; +  s[1:]    // 문자열은 변경할 수 없지만 슬라이스를 이용할 순 있습니다.  
fmt.Printf( &amp;quot;%s \n&amp;quot;, s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 여러 줄에 걸쳐서 문자열을 선언하고 싶다면 ``(백틱) 로 선언 할 수 있습니다. (모든 제어문자 무시)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := `hello
      world`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;`&lt;code&gt;로 둘러싸인 문자열은&lt;/code&gt;Raw 문자열&lt;code&gt;입니다. 즉, 문자열에서 나열된  형식&lt;/code&gt;그대로 인식`하는 형식 입니다.&lt;br /&gt;
문자열의 대체 치환 변경은 없습니다. 줄 바꿈문자(\n)는 그대로 출력 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;오류-유형:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;오류 유형&lt;/h3&gt;

&lt;p&gt;Go에는 &lt;code&gt;error&lt;/code&gt;형이라는 내장 형식이 있습니다. 오류 정보의 처리에 사용 됩니다.&lt;br /&gt;
또한 Go언어에는 &lt;code&gt;package&lt;/code&gt;에서 오류 처리를 할수 있는 &lt;code&gt;errors&lt;/code&gt;라는 패키지도 존재 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := errors.New( &amp;quot;emit macho dwarf : elf header corrupted&amp;quot;)
if err != nil {
    fmt.Print(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;데이터의-실제-저장-방식:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;데이터의 실제 저장 방식&lt;/h3&gt;

&lt;p&gt;아래의 그림은 &lt;a href=&#34;http://research.swtch.com/&#34;&gt;Russ Cox Blog&lt;/a&gt;에 포함되어 있는 내용입니다.&lt;br /&gt;
그중에서 &lt;a href=&#34;http://research.swtch.com/godata&#34;&gt;Go 데이터 구조&lt;/a&gt;에 대한 내용 입니다.&lt;/p&gt;

&lt;p&gt;기본 형식들이 실제 물리 메모리에 어떻게 관리되고 값을 저장하는지에 대해서 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.2.basic.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
그림 2.1 Go 데이터 저장 방식&lt;/p&gt;

&lt;h2 id=&#34;테크닉:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;테크닉&lt;/h2&gt;

&lt;h3 id=&#34;그룹화에-의한-선언:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;그룹화에 의한 선언&lt;/h3&gt;

&lt;p&gt;Go언어에서는 여러개의 정수·변수를 선언하거나 여러개의 패키지를 import 문으로 선언할 때, &lt;code&gt;그룹화&lt;/code&gt;를 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 같은 코드에서 그룹화를 이용해서 선언할 수 있습니다.(괄호 사용)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;
import &amp;quot;os&amp;quot;

const i = 100
const pi = 3.1415
const prefix = &amp;quot;Go_&amp;quot;

var i int
var pi float32
var prefix string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기의 코드를 그룹화를 이용하여 작성하면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import(
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &amp;quot;Go_&amp;quot;
)

var(
    i int
    pi float32
    prefix string
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iota-열거형:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;iota 열거형&lt;/h3&gt;

&lt;p&gt;Go 언어에는 &lt;code&gt;iota&lt;/code&gt;라는 키워드가 있습니다. 이 키워드는 &lt;code&gt;열거형(enum)&lt;/code&gt;을 선언 할 때 사용 됩니다.&lt;br /&gt;
기본값은 0부터 시작하여 순차적으로 값이 1씩 증가 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const(
    x = iota // x == 0
    y = iota // y == 1
    z = iota // z == 2
    w        // 상수 선언에서 값을 생략하면 기본값은 이전 값과 동일 합니다.  
             // 여기에서 z = iota 로 선언하고 있으므로, 다음값인 w == 3 입니다.  
             // 사실 예제에서  y와 z 값도 사실 &amp;quot;= iota&amp;quot;는 생략 할 수 있습니다.
)

const v = iota // const 키워드를 사용할 때마다, iota 값은 리셋됩니다. 즉,v == 0 입니다.

const(
    e, f, g = iota, iota, iota  // e = 0, f = 0, g = 0 iota 와 동일 합니다
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 값으로 상수의 값을 설정한 것과 &lt;code&gt;iota&lt;/code&gt;에 설정되어 있는 것을 제외하고,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;각 &lt;code&gt;const&lt;/code&gt; 그룹의 시작 상수는 기본적으로 0 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두번째 이후의 상수는 이전 상수 값을 기본값으로 사용 합니다.&lt;br /&gt;
이전 상수의 값이&lt;code&gt;iota&lt;/code&gt;면 후의 값도&lt;code&gt;iota&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&#34;go-프로그램의-디자인-규칙:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;Go 프로그램의 디자인 규칙&lt;/h3&gt;

&lt;p&gt;Go 언어가 간결함을 유지할 수 있는 것은 다음과 같은 기본적인 규칙들이 있기 때문입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;대문자로 시작하는 변수는 외부에 공개 됩니다. (Public)&lt;br /&gt;
즉, 다른 패키지에서 읽을 수있는 &lt;code&gt;공용 변수&lt;/code&gt;라는 의미 입니다. 소문자로 시작하는 변수는 외부에서 접근할 수 없습니다.&lt;br /&gt;
즉, &lt;code&gt;내부 변수&lt;/code&gt;입니다.( Public / Private 에 해당)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;대문자로 시작하는 함수 또한 마찬가지 입니다.&lt;br /&gt;
대문자로 시작하는 변수/함수는 객체지향언어 에서 &lt;code&gt;class&lt;/code&gt;의 &lt;code&gt;public&lt;/code&gt; 키워드와 동일한 의미 입니다.&lt;br /&gt;
소문자로 시작하는 변수/함수는 &lt;code&gt;private&lt;/code&gt; 키워드와 그 의미가 동일 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;array-slice-map:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;array, slice, map&lt;/h2&gt;

&lt;h3 id=&#34;array:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;array&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;array&lt;/code&gt; 는 &lt;strong&gt;배열&lt;/strong&gt; 입니다. 배열형의 정의는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var arr[n] type
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;배열은 반드시 [n]과 같이 &lt;strong&gt;크기&lt;/strong&gt;가 지정 됩니다.!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;[n] type&lt;/code&gt;에서 &lt;code&gt;n&lt;/code&gt;은 배열의 길이를 나타 냅니다. &lt;code&gt;type&lt;/code&gt;은 배열 항목의 개별 형식을 의미 합니다.&lt;br /&gt;
배열에 대한 조작 방식은 다른 언어와 비슷하며, &lt;code&gt;[]&lt;/code&gt;을 통해서 값을 대입하거나 추출 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var arr[10] int     // int 형의 배열을 선언 합니다.
arr [0] = 42        // 배열의 인덱스는 0부터 시작 합니다.
arr [1] = 13        // 대입
fmt.Printf(&amp;quot;The first element is %d \n&amp;quot;, arr[0]) // 데이터를 추출하여 42를 반환 합니다.
fmt.Printf(&amp;quot;The last element is %d \n&amp;quot;, arr[9]) 
// 값이 할당되지 않은 마지막 요소를 반환 합니다. 초기화를 하지 않았으므로, 0이 반환 됩니다.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;길이값은 배열의 일부&lt;/code&gt;이므로 &lt;code&gt;[3]int&lt;/code&gt; 과 &lt;code&gt;[4]int&lt;/code&gt; 는 완전히 다른 형식 입니다.배열도 &lt;em&gt;길이를 변경할 수 없습니다&lt;/em&gt;.&lt;br /&gt;
배열간의 대입은 &lt;code&gt;값으로 전달&lt;/code&gt; 합니다. 즉,배열이 함수의 인수로 사용 된  경우 전달 되는 값은, 배열의 &lt;strong&gt;복사본&lt;/strong&gt;이며,&lt;br /&gt;
타언어에서와 같이 포인터가(레퍼런스) 아닙니다. 만약 포인터형식으로 사용 하려면 뒤에 소개하는 &lt;code&gt;slice&lt;/code&gt;를  이용 하십시오.&lt;/p&gt;

&lt;p&gt;배열 또한 &lt;code&gt;:=&lt;/code&gt;로 단축선언 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := [3]int{1, 2, 3}     // 길이가 3인 int 배열을 선언하면서 값으로 초기화 합니다.  
b := [10]int{1, 2, 3}    // 길이가 10의 int 배열을 선언하고 초기화 합니다.   
                         // 이 중 3 가지 요소의 초기 값은 1,2,3이고, 나머지는 0입니다.  
c := [...]int{4, 5, 6}   // 길이값에 `...`를 사용해서 크기를 자동계산 할 수 있습니다.    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;배열의 배열&lt;/code&gt;을 사용할 수도 있습니다. Go는 중첩배열을 지원 합니다.&lt;br /&gt;
예를 들어 다음 코드는 이차원 배열을 선언하고 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 이차원 배열을 하나 선언 합니다. 이 배열은 두 개의 배열을 요소로하고 
// 각 배열에는 4 개의 int 형의 요소가 포함되어 있습니다.
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 위의 선언은 단순화 할 수 있습니다.
easyArray := [2][4]int{ {1, 2, 3, 4}, {5, 6, 7, 8}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;배열의 상태는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.2.array.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.2 다차원 배열의 매핑 관계&lt;/p&gt;

&lt;h3 id=&#34;slice:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;slice&lt;/h3&gt;

&lt;p&gt;많은 응용 프로그램에서 배열만 사용해서는 요구사항을 모두 충족할 수 없습니다.때로는 어느 정도 크기의 배열이&lt;br /&gt;
필요할지 모르는 경우도 존재하기 때문입니다. 따라서 &amp;ldquo;동적 배열&amp;rdquo;이 필요 합니다.&lt;br /&gt;
Go는 이러한 &lt;code&gt;동적 배열&lt;/code&gt;을 가능하게 만들어 주는 데이터 구조를 &lt;code&gt;slice&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slice&lt;/code&gt;는 진정한 의미의 동적 배열은 아닙니다. 단순한 참조형식 일 뿐입니다.&lt;br /&gt;
&lt;code&gt;slice&lt;/code&gt;는 실제로는 &lt;code&gt;array&lt;/code&gt;형태로 내부적으로 처리 됩니다.&lt;br /&gt;
&amp;gt;&lt;code&gt;slice&lt;/code&gt; 선언은  &lt;code&gt;array&lt;/code&gt;와 같이 &lt;strong&gt;길이를 지정할 필요가 없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// array 선언과 동일하지만 길이를 지정하지 않습니다.   
var fslice[] int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slice&lt;/code&gt;를 선언함과 동시에 데이터를 초기화 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := []byte { &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;slice&lt;/code&gt;는 배열 또는 이미 존재하는 &lt;code&gt;slice&lt;/code&gt; 내부에서도 선언 할 수 있습니다.&lt;br /&gt;
&lt;code&gt;slice&lt;/code&gt;는 &lt;code&gt;array[i:j]&lt;/code&gt;형식으로 그 값을 얻을 수 있습니다. &lt;code&gt;i&lt;/code&gt;는 배열의 시작 위치이며, &lt;code&gt;j&lt;/code&gt;는 끝위치 입니다.&lt;br /&gt;
그러나 &lt;code&gt;array[j]&lt;/code&gt;는 그 값에 포함되지 않습니다. 즉, 길이는 &lt;code&gt;j-i&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 10개의 요소를 선언 합니다. 요소의 형태는 byte의 배열 입니다.
var ar = [10] byte{ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;,​​ &#39;f&#39;, &#39;g&#39;, &#39;h&#39; &#39;i&#39;, &#39;j&#39;}

// byte를 포함한 2 개의 slice를 선언 합니다
var a, b []byte

// ar 슬라이스의 세 번째 요소에서 시작하여 5 번째 요소       
a = ar[2 : 5]

// 현재 a 변수가 가지는 값은  ar[2] ar[3]과 ar[4] 입니다.     

// b는 배열 ar의 또 다른 slice입니다.
b = ar[3 : 5]

// b의 요소는 ar[3]과 ar[4]입니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt;와 &lt;code&gt;array&lt;/code&gt;는 선언시에 길이값으로
구분되므로 주의 하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;배열은 선언 할 때 괄호안에([]) 배열의 길이를 명시하거나 &lt;code&gt;...&lt;/code&gt; 를 사용해서 자동으로 길이를 계산 합니다.&lt;br /&gt;
한편 &lt;code&gt;slice&lt;/code&gt;를 선언 할 때는 괄호([]) 안에 크기를 지정하는 문자가 없습니다.&lt;/p&gt;

&lt;p&gt;이러한 데이터 구조는 다음과 같이되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.2.slice.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.3 slice와 array의 대응 관계도&lt;/p&gt;

&lt;p&gt;slice는 다음과 같이 사용됩니다.&lt;/p&gt;

&lt;p&gt;-&lt;code&gt;slice&lt;/code&gt;의 기본 시작 위치는 암시적으로 0 입니다. &lt;code&gt;ar[:n]&lt;/code&gt;은 &lt;code&gt;ar[0:n]&lt;/code&gt;과 같습니다.&lt;br /&gt;
 -&lt;code&gt;slice&lt;/code&gt;의 두 번째 값은 배열의 길이를 의미 합니다. &lt;code&gt;ar[n:]&lt;/code&gt; 은 &lt;code&gt;ar[n:len(ar)]&lt;/code&gt;과 같습니다.&lt;br /&gt;
 - 만약 &lt;code&gt;slice&lt;/code&gt;의 모든값이 필요할 경우 경우에는, &lt;code&gt;ar[:]&lt;/code&gt;라는 형태로 사용 할 수 있습니다.&lt;br /&gt;
   왜냐하면 기본 시작 값은 0이고, 두 번째는 배열의 길이에 해당하기때문 입니다. 즉&lt;code&gt;ar[0:len(ar)]&lt;/code&gt;과 같습니다.&lt;/p&gt;

&lt;p&gt;다음은 &lt;code&gt;slice&lt;/code&gt;로 작업하는 몇가지 예제 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 배열을 선언
var array = [10] byte{ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;,​​ &#39;f&#39;, &#39;g&#39;, &#39;h&#39; &#39;i&#39;, &#39;j&#39;}
// slice를 2 개 선언
var aSlice, bSlice []byte

// 조작 
aSlice = array[3]  // aSlice = array[0:3]과 동일.  aSlice 요소: a, b, c
aSlice = array[5:] // aSlice = array[5:10]과 동일. aSlice 요소: f, g, h, i, j
aSlice = array[:]  // aSlice = array[0:10]과 동일. aSlice에는 모든 요소가 포함되어 있습니다.

// slice에서 slice를 추출 
aSlice = array[3:7]  // aSlice 요소: d, e, f, g, len = 4, cap = 7
bSlice = aSlice[1:3] // bSlice에는 aSlice[1] aSlice[2]가 포함되며 각각의 요소는 다음과 같습니다 : e, f
bSlice = aSlice[3]   // bSlice에는 aSlice[0], aSlice[1] aSlice[2]가 포함됩니다. 각각 다음과 같습니다 : d, e, f
bSlice = aSlice[0:5] // slice의 cap의 범위 내에서 확장 할 수 있습니다. bSlice는 다음 요소가 포함됩니다 : d, e, f, g, h
bSlice = aSlice[:]   // bSlice에는 aSlice의 모든 요소를​​ 포함합니다 : d, e, f, g
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt;는 &lt;strong&gt;참조 형&lt;/strong&gt;이므로, 값을 변경하면
다른 모든 참조에서도 값이 변경 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 위의 &lt;code&gt;aSlice&lt;/code&gt;와 &lt;code&gt;bSlice&lt;/code&gt;에서 &lt;code&gt;aSlice&lt;/code&gt;의 요소를 변경하면 &lt;code&gt;bSlice&lt;/code&gt;의 해당 값도 변경 됩니다.&lt;/p&gt;

&lt;p&gt;개념적으로는 &lt;code&gt;slice&lt;/code&gt;는 구조체 입니다. 이 구조체에는 3 개의 요소가 포함되어 있습니다.&lt;br /&gt;
- 첫번째는, 포인터 입니다. 배열의 &lt;code&gt;slice&lt;/code&gt;가 나타내는 시작 위치를 가리 킵니다.&lt;br /&gt;
- 두번째는, 길이, 즉 &lt;code&gt;slice&lt;/code&gt;의 길이 입니다.&lt;br /&gt;
- 세번째는, 최대 길이, &lt;code&gt;slice&lt;/code&gt;의 시작 위치에서 배열의 마지막 위치까지의 길이 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Array_a := [10]byte{ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;,​​ &#39;f&#39;, &#39;g&#39;, &#39;h&#39; &#39;i&#39;, &#39;j&#39;}
Slice_a := Array_a[2:5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드의 데이터 저장 구조는 다음 그림과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.2.slice2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.4 slice에 대응되는 배열정보&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slice&lt;/code&gt;에는 몇 가지 유용한 내장 함수가 있습니다.&lt;/p&gt;

&lt;p&gt;-&lt;code&gt;len()&lt;/code&gt;     &lt;code&gt;slice&lt;/code&gt;의 길이를 반환 합니다.&lt;br /&gt;
-&lt;code&gt;cap()&lt;/code&gt;     &lt;code&gt;slice&lt;/code&gt;의 최대 용량을 반환 합니다.&lt;br /&gt;
-&lt;code&gt;append()&lt;/code&gt;  &lt;code&gt;slice&lt;/code&gt;에 하나 이상의 요소를 추가합니다. 그 후&lt;code&gt;slice&lt;/code&gt;와 같은 형태의&lt;code&gt;slice&lt;/code&gt;을 반환 합니다.&lt;br /&gt;
-&lt;code&gt;copy()&lt;/code&gt;    원래&lt;code&gt;slice&lt;/code&gt;의 &lt;code&gt;src&lt;/code&gt;를 &lt;code&gt;dst&lt;/code&gt;요소에 복사하고 복사 된 요소의 개수를 반환 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 함수는 &lt;code&gt;slice&lt;/code&gt;가 참조하는 배열의 &lt;strong&gt;내용&lt;/strong&gt;을 변경하는 것입니다.&lt;br /&gt;
따라서 참조와 동일한 배열의 다른&lt;code&gt;slice&lt;/code&gt;에도 영향을 줍니다. 그러나&lt;code&gt;slice&lt;/code&gt;에 공간이 없는(&lt;code&gt;(cap-len) == 0&lt;/code&gt;) 경우&lt;br /&gt;
동적 메모리에 새로운 배열 공간이 할당 됩니다. 반환되는 &lt;code&gt;slice&lt;/code&gt; 배열의 포인터는 이 공간을 가리키고 있습니다.&lt;br /&gt;
또한 원래 배열의 내용은 바뀌지 않습니다. 이 배열을 참조하는 다른&lt;code&gt;slice&lt;/code&gt;은 영향을 받지 않게 됩니다.&lt;/p&gt;

&lt;p&gt;Go 1.2에서 부터, slice는 3개의 인수를 사용하는 slice를 지원합니다.&lt;/p&gt;

&lt;p&gt;이전까지 다음과 같은 방법으로 slice 또는 array에서 slice를 제거 했습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var array [10]int
slice := array[2:4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예제는 slice의 요소 수는 8이고, 새 버전에서는 다음과 같이 요소 수를 지정할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slice = array[2:4:7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예제에서 요소 수는 &lt;code&gt;7-2&lt;/code&gt;, 즉 5입니다. 이렇게 생성된 새로운 slice는 마지막 3 가지 요소에 액세스하는 방법이 없습니다.&lt;/p&gt;

&lt;p&gt;만약 slice가 &lt;code&gt;array[:i:j]&lt;/code&gt; 같은 형식이라면 첫 번째 인수를 기본으로 간주하며, 기본값은 0 입니다.&lt;/p&gt;

&lt;h3 id=&#34;map:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;map&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt;의 개념은 Python 사전과 동일 합니다. 이 형식은 &lt;code&gt;map[keyType]valueType&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;아래의 코드를 참조 하시기 바랍니다.&lt;br /&gt;
&lt;code&gt;map&lt;/code&gt;의 사용법은 &lt;code&gt;slice&lt;/code&gt;와 &lt;strong&gt;유사&lt;/strong&gt;합니다. 단지  &lt;code&gt;key&lt;/code&gt; 값을 통해서 데이터를 조작 합니다.&lt;br /&gt;
차이점은 &lt;code&gt;slice&lt;/code&gt;의 &lt;code&gt;index&lt;/code&gt;는 &lt;code&gt;int&lt;/code&gt;유형 이어야만 합니다. &lt;code&gt;map&lt;/code&gt;의 &lt;code&gt;index&lt;/code&gt;는 많은 형태가 있습니다.&lt;br /&gt;
&lt;code&gt;int&lt;/code&gt;도 될 수 있으며, &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt;와 &lt;code&gt;!=&lt;/code&gt; 등 연산자가 정의되어 있는 어떤 형태라도 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// key가 문자열이며 값은 int인 map을 선언합니다.    
// 이 Map은 사용하기 전에 `make로 초기화` 되어야 합니다.
var numbers map[string] int

// 또 다른 map의 선언 방법
numbers := make(map[string] int)
numbers[ &amp;quot;one&amp;quot;] = 1           // 대입
numbers[ &amp;quot;ten&amp;quot;] = 10          // 대입
numbers[ &amp;quot;three&amp;quot;] = 3

fmt.Println( &amp;quot;세 번째 숫자는 :&amp;quot;, numbers[&amp;quot;three&amp;quot;])   // 데이터 검색
// &amp;quot;세 번째 숫자는 : 3&amp;quot; 라는 형식으로 출력 됩니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;map&lt;/code&gt; 은 일반적으로 사용하는 표와 아주 유사하며, 열값에 &lt;code&gt;key&lt;/code&gt;, 행값에 &lt;code&gt;value&lt;/code&gt; 값이 있습니다.&lt;/p&gt;

&lt;p&gt;map을 사용할 경우 몇가지 주의사항이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;은 데이터의 순서가 없습니다.&lt;br /&gt;
&lt;code&gt;map&lt;/code&gt;의 출력 내용은 매번 다르게 출력될 수 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt;로 값을 얻을 수 없으며 항상 &lt;code&gt;key&lt;/code&gt;를 사용해서 값을 추출해야 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;의 길이는 고정되지 않습니다.&lt;br /&gt;
이점은 &lt;code&gt;slice&lt;/code&gt;와 같으며, 참조 형의 일종 입니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;내장 &lt;code&gt;len()&lt;/code&gt; 함수를 &lt;code&gt;map&lt;/code&gt;에 적용하면 &lt;code&gt;map&lt;/code&gt;이 가지는 &lt;code&gt;key&lt;/code&gt;의 개수를 반환 합니다.&lt;br /&gt;
-&lt;code&gt;map&lt;/code&gt;값은 쉽게 다룰 수 있습니다.&lt;br /&gt;
&lt;code&gt;numbers[&amp;quot;one&amp;quot;] = 11&lt;/code&gt;와 같이 key가 &lt;code&gt;one&lt;/code&gt;인 사전의 값을 &lt;code&gt;11&lt;/code&gt;로 변경 합니다.&lt;br /&gt;
-&lt;code&gt;map&lt;/code&gt;은 다른 기본형과 달리, &lt;code&gt;thread-safe&lt;/code&gt;하지 않습니다.&lt;br /&gt;
즉, 여러 go-routine을 다룰 때는 반드시 mutex lock 메커니즘을 사용해야만 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 초기화는 &lt;code&gt;key:val&lt;/code&gt; 방법으로 초기 값을 줄 수 있습니다.&lt;br /&gt;
또한 동시에 &lt;code&gt;map&lt;/code&gt;에는 기본적으로 &lt;code&gt;key&lt;/code&gt;가 존재하는지 확인하는 방법이 존재 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;delete&lt;/code&gt;함수로 &lt;code&gt;map&lt;/code&gt; 요소를 삭제 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 사전을 초기화 합니다.
rating := map[string] float32{ &amp;quot;C&amp;quot;: 5, &amp;quot;Go&amp;quot;: 4.5 &amp;quot;Python&amp;quot;: 4.5 &amp;quot;C ++&amp;quot;: 2}

// map은 2 개의 반환 값을 가집니다. 첫번째는 해당 키의 값이며, 두 번째 반환 값은 
// 만약 key가 존재하지 않으면 false가 존재하면 true 값을 반환 합니다.   
csharpRating, ok := rating[&amp;quot;C#&amp;quot;]
if ok {
    fmt.Println(&amp;quot;C# is in the map and its rating is&amp;quot;, csharpRating)
} else {
    fmt.Println(&amp;quot;We have no rating associated with C# in the map&amp;quot;)
}

delete(rating &amp;quot;C&amp;quot;) // key가 C의 요소를 제거 합니다.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 말한 것처럼 &lt;code&gt;map&lt;/code&gt;은 참조 형의 일종이기 때문에 만약 2 개의 &lt;code&gt;map&lt;/code&gt;이 동일한 포인터를 가리키는&lt;br /&gt;
경우 하나를 변경한다면 또다른 맵의 값도 변경 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := make(map[string] string)
m[&amp;quot;Hello&amp;quot;] = &amp;quot;Bonjour&amp;quot;
m1 := m
m1[&amp;quot;Hello&amp;quot;] = &amp;quot;Salut&amp;quot;      // 이때 m[&amp;quot;hello&amp;quot;] 값도 변경 됩니다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make-new-메모리-조작:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;make, new 메모리 조작&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt;은 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;slice&lt;/code&gt; 및&lt;code&gt;channel&lt;/code&gt;의 메모리를 생성 및 할당 합니다.&lt;br /&gt;
&lt;code&gt;new&lt;/code&gt;는 각 형태의 메모리를 생성 및 할당 합니다.&lt;/p&gt;

&lt;p&gt;내장 함수 &lt;code&gt;new()&lt;/code&gt;는 다른 언어에서 사용되는 메모리할당문인 &lt;code&gt;new()&lt;/code&gt; 함수와 동일 합니다.&lt;br /&gt;
&lt;code&gt;new(T)&lt;/code&gt;는 0으로 초기화된 &lt;code&gt;T&lt;/code&gt; 형의 메모리 공간을 할당한 후 그 주소를 반환 합니다. 즉 &lt;code&gt;*T&lt;/code&gt; 형 값입니다.&lt;br /&gt;
Go용어로 말하면, 포인터를 반환하는 것입니다. 새롭게 할당 된 타입 &lt;code&gt;T&lt;/code&gt;는 0 입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;중요한 점은 &lt;code&gt;new&lt;/code&gt;는 포인터를 반환 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내장 함수&lt;code&gt;make(T, args)&lt;/code&gt;는 &lt;code&gt;new(T)&lt;/code&gt;와는 다른 기능을 가지고 있습니다.&lt;br /&gt;
make는 &lt;code&gt;slice&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; 또는&lt;code&gt;channel&lt;/code&gt;을 만들고 초기값(0이 아닌 값)을 가진&lt;code&gt;T&lt;/code&gt; 형을 반환하므로, &lt;code&gt;*T&lt;/code&gt;가 없습니다.&lt;br /&gt;
기본적으로 이 3 가지 형태가 다른 점은 데이터 구조를 가리키는 참조가 사용되기 전에 초기화되느냐의 여부입니다.&lt;br /&gt;
예를 들어, 데이터(내부&lt;code&gt;array&lt;/code&gt;)를 가리키는 포인터, 길이, 용량에 따른 3 가지로 설명되는 &lt;code&gt;slice&lt;/code&gt;의 각 항목이&lt;br /&gt;
초기화되기 전에는 &lt;code&gt;slice&lt;/code&gt;의 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. &lt;code&gt;slice&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;channel&lt;/code&gt;에서, make는 내부 데이터 구조를&lt;br /&gt;
초기화하고 적당한 값으로 대입됩니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt;는 초기화를 수행한 후 값을 반환 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음 그림은 &lt;code&gt;new&lt;/code&gt;와 &lt;code&gt;make&lt;/code&gt;의 차이점에 대해서 자세히 설명하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.2.makenew.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
그림 2.5 make와 new 의 실제 메모리 할당 방식&lt;/p&gt;

&lt;h2 id=&#34;제로-값:2ef2f3fc9ee3102fd2ffea6f9cac38b4&#34;&gt;제로 값&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;제로 값&amp;rdquo;은 값이 비어있다는 의미가 아니며, 암시적인 초기값 이라는 의미입니다.&lt;br /&gt;
이것은 &amp;ldquo;변수의 생성시 초기&amp;rdquo;의 기본값이며, 일반적으로 0 입니다.  각 유형별 제로 값은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int          0
int8         0
int32        0
int64        0
uint         0x0
rune         0      // rune의 실제 형태는 int32입니다.
byte         0x0    // byte의 실제 형태는 uint8입니다.
float32      0      // 길이는 4 byte
float64      0      // 길이는 8 byte
bool         false
string       &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/03] Control Statements and Functions</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/03-control-statements-and-functions</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/03-control-statements-and-functions</guid>
      <description>

&lt;h1 id=&#34;control-statements-and-functions:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;Control Statements and Functions&lt;/h1&gt;

&lt;p&gt;이 절에서는 Go 언어의 &lt;code&gt;흐름 제어&lt;/code&gt;&lt;code&gt;및&lt;/code&gt;함수`에 대해서 설명 합니다.&lt;/p&gt;

&lt;h2 id=&#34;흐름-제어:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;흐름 제어&lt;/h2&gt;

&lt;p&gt;흐름 제어는 프로그래밍 기능중에서 가장 중요한 기능입니다. 왜냐하면 흐름제어를 통해서 매우 간단한 로직에서 부터&lt;br /&gt;
복잡한 로직까지 표현 할 수 있기 때문 입니다. Go언어의 흐름 제어는 크게 세 부분으로 구성되어 있습니다.&lt;br /&gt;
바로 &lt;code&gt;조건문, 판단문, 루프 제어 및 무조건 점프&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&#34;if:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;는 모든 프로그래밍 언어에서 가장 자주 사용하는 구문중 하나일 것입니다.&lt;br /&gt;
이 문법을 대략적으로 설명하면, 만약 조건을 만족하면 무엇을하고 만족하지 않으면 어떤 행동을 할지를 결정하는 것입니다.&lt;/p&gt;

&lt;p&gt;Go 언어에서는 &lt;code&gt;if&lt;/code&gt; 분기문의 특징은 &lt;strong&gt;비교조건에 괄호를 사용할 필요가 없습니다.&lt;/strong&gt; 다음 코드를 참고 하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if x&amp;gt; 10 {
    fmt.Println(&amp;quot;x is greater than 10&amp;quot;)
} else {
    fmt.Println(&amp;quot;x is less than 10&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go의 &lt;code&gt;if&lt;/code&gt;문의 장점중 하나는 &lt;code&gt;조건 분기에서 변수를 선언&lt;/code&gt;할 수 있습니다.&lt;br /&gt;
이렇게 선언한 변수의 범위는 선언된 블록내에만 존재하며 다른 곳에서는 사용할 수 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// x 값을 계산한 후 x의 크기를 반환 합니다. 예제에서는 10 이상 여부를 판단 합니다.
if x := computedValue(); x &amp;gt; 10 {
    fmt.Println(&amp;quot;x is greater than 10&amp;quot;)
} else {
    fmt.Println(&amp;quot;x is less than 10&amp;quot;)
}

// 만약 이렇게 호출하면 컴파일 오류 입니다. x는 조건문 내에서만 사용하는 변수이기 때문 입니다.    
fmt.Println(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한, 여러가지 조건별로 검사를 할 수도 있습니다. 예제는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if integer == 3 {
    fmt.Println(&amp;quot;The integer is equal to 3&amp;quot;)
} else if integer &amp;lt; 3 {
    fmt.Println(&amp;quot;The integer is less than 3&amp;quot;)
} else {
    fmt.Println(&amp;quot;The integer is greater than 3&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;goto:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;goto&lt;/h3&gt;

&lt;p&gt;Go언어에도 &lt;code&gt;goto&lt;/code&gt; 키워드가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;반드시 사용할 곳에만 현명하게 사용하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;goto&lt;/code&gt; 문은 반드시 함수내에서 미리 정의 된 태그(레이블)로 이동 합니다.&lt;br /&gt;
예를 들어 이러한 루프가 있다고 가정 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func myFunc() {
    i := 0
Here :           //행의 첫컬럼에서 시작하고 콜론을 마지막에 사용하여 태그로 표시 합니다.     
    println(i)
    i++
    goto Here   // Here로 이동 합니다.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;태그 이름은 대소문자를 구별 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;for:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;for&lt;/h3&gt;

&lt;p&gt;Go언어에서 가장 &lt;strong&gt;강력한 컨트롤 문장&lt;/strong&gt;이라면 단연, &lt;code&gt;for&lt;/code&gt; 문장 입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Go언어의 반복문은 &lt;code&gt;for&lt;/code&gt;문 &lt;strong&gt;하나 뿐&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;반복문을 이용해서, 데이터를 모두 읽어 내는 용도 등에 사용할 수 있습니다.&lt;br /&gt;
일반적인 언어에서 &lt;code&gt;while, do while, for&lt;/code&gt;문장을 한개로 사용한다고 생각하시면 됩니다.  문법은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for expression1; expression2; expression3 {
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;expression1&lt;/code&gt;, &lt;code&gt;expression2&lt;/code&gt;, &lt;code&gt;expression3&lt;/code&gt;은 식 입니다.&lt;br /&gt;
&lt;code&gt;expression1&lt;/code&gt;과 &lt;code&gt;expression3&lt;/code&gt;은 변수 선언이나 함수 호출의 반환 값을 사용할 수 있습니다.&lt;br /&gt;
&lt;code&gt;expression2&lt;/code&gt;는 반복문 의사 결정에 사용 됩니다. 이 문장의 흐름은 다음과 같습니다.&lt;br /&gt;
&lt;code&gt;expression1&lt;/code&gt;문장은 루프가 시작되기 전에 호출 됩니다. &lt;code&gt;expression3&lt;/code&gt; 반복 할 때 마지막으로 호출 됩니다.&lt;/p&gt;

&lt;p&gt;이렇게 설명하는 것보다는 예제를 보는 편이 빠르겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

func main() {
    sum := 0;
    for index := 0; index &amp;lt; 10; index++ {
        sum += index
    }
    
    fmt.Println(&amp;quot;sum is equal to&amp;quot;, sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 출력됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum is equal to 45&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;때로는 여러개의 변수할당을 할 경우가 있습니다. Go언어에는 콤마연산자(,)가 없기 때문에 병행할당을 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;i, j = i + 1, j-1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;또한, &lt;code&gt;expression1&lt;/code&gt;과 &lt;code&gt;expression3&lt;/code&gt;를 생략 할 수 도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sum := 1
for ; sum &amp;lt;1000 ; {
    sum += sum
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예제에서는 &lt;code&gt;;&lt;/code&gt;을 생략 할 수 있습니다. 다음과 같은 코드는 동일한 기능을 수행 합니다.&lt;br /&gt;
어디선가 낯이 익지 않습니까? 바로 다른언어의 &lt;code&gt;while&lt;/code&gt; 문의 기능 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sum := 1
for sum &amp;lt; 1000 {
    sum += sum
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;반복문에서는 &lt;code&gt;break&lt;/code&gt;와&lt;code&gt;continue&lt;/code&gt; 두 가지 명령을 사용할 수 있습니다.&lt;br /&gt;
&lt;code&gt;break&lt;/code&gt;는 현재 루프에서 탈출하며, &lt;code&gt;continue&lt;/code&gt;는 조건 검사로 점프 합니다.&lt;br /&gt;
중첩 된 반복문의 경우&lt;code&gt;break&lt;/code&gt; 명령으로, 한번에 중첩 반복문을 탈출 할 수 있습니다.&lt;br /&gt;
다음은 그 사용 예제입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for index := 10; index &amp;gt; 0; index-- {
    if index == 5 {
        break      // 또는 continue
    }
    fmt.Println(index)
}
// break문이라면  10,9,8,7,6이 출력 됩니다.
// continue문의 경우 10,9,8,7,6,4,3,2,1이  출력 됩니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;와&lt;code&gt;continue&lt;/code&gt; 는 이름(태그)을 지정해서 사용할 수 있습니다.&lt;br /&gt;
여러번 중첩된 루프에서 바깥쪽 루프로 한번에 점프하는 데 사용 됩니다. (break goto_label)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;문장의 주요 용도는 &lt;code&gt;range&lt;/code&gt; 키워드와 함께 사용해서 &lt;code&gt;slice&lt;/code&gt;와&lt;code&gt;map&lt;/code&gt;의 데이터를 액세스 할 경우 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for k, v := range map {
    fmt.Println(&amp;quot;map &#39;s key :&amp;quot;, k)
    fmt.Println(&amp;quot;map &#39;s val :&amp;quot;, v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Go는 &amp;ldquo;여러개의 반환 값&amp;rdquo;을 반환하는 기능을 제공 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하지만, 선언만하고 사용하지 않는 변수는 컴파일러 오류를 출력 합니다.&lt;br /&gt;
이런 상황에서 &lt;code&gt;_&lt;/code&gt;를 사용하여 필요없는 반환 값을 무시할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _ , v := range map {
    fmt.Println(&amp;quot;map &#39;s val :&amp;quot;, v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기의 코드에서는 &lt;code&gt;_&lt;/code&gt;문자로 변수 값을 무시했으므로, 컴파일 오류가 발생하지 않습니다.&lt;/p&gt;

&lt;h3 id=&#34;switch:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;switch&lt;/h3&gt;

&lt;p&gt;수 많은 &lt;code&gt;if-else&lt;/code&gt;를 사용해서 로직 처리해야하는 경우가 종종 있습니다.&lt;br /&gt;
이런 많은류의 분기 코드는 보기에도 좋지 않고, 읽기도 좋지 않습니다. 또한 유지 보수도 쉽지 않게 되므로,&lt;br /&gt;
이런 문제는 &lt;code&gt;switch&lt;/code&gt;문을 사용하면 간단히 해결 할 수 있습니다. 이 문법은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch sExpr {
    case expr1:
        some instructions
    case expr2:
        some other instructions
    case expr3:
        some other instructions
    default:
        other code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sExpr&lt;/code&gt;과 &lt;code&gt;expr1&lt;/code&gt;&lt;code&gt;expr2&lt;/code&gt;&lt;code&gt;expr3&lt;/code&gt;의 유형은 *정확히 일치**해야 합니다.&lt;br /&gt;
Go의&lt;code&gt;switch&lt;/code&gt;문은 사용하기 편리하며, 식(expression)에 반드시 정수만 사용할 수 있는것이 아닙니다.&lt;br /&gt;
실행 과정은 위에서 아래까지 case문장 중 &lt;strong&gt;일치하는 항목&lt;/strong&gt;을 찾을 때까지 수행 됩니다.&lt;br /&gt;
만약 &lt;code&gt;switch&lt;/code&gt;에 일치하는 식이 없으면, &lt;code&gt;default&lt;/code&gt; 문장을 수행 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i := 10
switch i {
    case 1:
        fmt.Println(&amp;quot;i is equal to 1&amp;quot;)
    case 2, 3, 4:
        fmt.Println(&amp;quot;i is equal to 2, 3 or 4&amp;quot;)
    case 10:
        fmt.Println(&amp;quot;i is equal to 10&amp;quot;)
    default:
        fmt.Println( &amp;quot;All I know is that i is an integer&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기 예제에서는 7번째 줄의 case문이 수행 됩니다.&lt;/p&gt;

&lt;p&gt;Go의 &lt;code&gt;switch&lt;/code&gt;은 기본적으로 &lt;code&gt;case&lt;/code&gt;의 마지막에 &lt;code&gt;break&lt;/code&gt;문이 있는 것으로 간주하기 때문에,&lt;br /&gt;
case를 실행한 후에 곧바로 switch문을 벗어나게 됩니다. 만약, &lt;code&gt;fallthrough&lt;/code&gt; 키워드를 사용한다면,&lt;br /&gt;
해당 case 코드를 수행한 후 다음 case문을 수행할 수도 있습니다. 다음은 그 사용 예제입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;integer := 6
switch integer {
    case 4:
        fmt.Println(&amp;quot;The integer was &amp;lt;= 4&amp;quot;)
        fallthrough
    case 5:
        fmt.Println(&amp;quot;The integer was &amp;lt;= 5&amp;quot;)
        fallthrough
    case 6:
        fmt.Println(&amp;quot;The integer was &amp;lt;= 6&amp;quot;)
        fallthrough
    case 7:
        fmt.Println(&amp;quot;The integer was &amp;lt;= 7&amp;quot;)
        fallthrough
    case 8:
        fmt.Println(&amp;quot;The integer was &amp;lt;= 8&amp;quot;)
        fallthrough
    default:
        fmt.Println( &amp;quot;default case&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기의 코드는 다음과 같이 출력 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The integer was &amp;lt;= 6
The integer was &amp;lt;= 7
The integer was &amp;lt;= 8
default case
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;함수:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;함수&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;함수는 Go언어의 가장 핵심 중의 핵심입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;키워드 &lt;code&gt;func&lt;/code&gt; 으로 함수를 선언 합니다. 함수 선언 형식은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    // 로직 처리 코드입니다.
    // 여러 값을 반환 합니다.
    return value1, value2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드를 통해서 다음과 같은 것을 알 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;키워드&lt;code&gt;func&lt;/code&gt;을 이용해서 &lt;code&gt;funcName&lt;/code&gt;라는 함수를 선언 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;함수는 하나 이상의 인수를 취할 수 있고, 인수의 이름 뒤에 인수의 형식을 지정합니다. 콤마(,)를 구분자로 사용 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;함수는 한번에 여러개의 반환 값을 반환 할 수 있습니다.&lt;br /&gt;
예제에서는 두 변수 &lt;code&gt;output1&lt;/code&gt;과 &lt;code&gt;output2&lt;/code&gt;에 반환 됩니다. 반환 변수의 이름은 생략해도 무관 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;만약 하나의 반환 값만 존재한다면, 반환 값의 괄호를 생략 할 수 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;만약 반환 값이 없다면, 반환 값의 정보도 생략 할 수 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;만약 반환 값이 있으면 함수에서 return 문을 추가해야 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음은 실제로, 함수를 사용하는 예제 입니다. (Max 값을 계산 합니다)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

// a, b 중 최대 값을 반환 합니다.
func max(a, b int) int {
    if a &amp;gt; b {
        return a
    }
    return b
}

func main() {
    x := 3
    y := 4
    z := 5

    max_xy := max(x, y) // 함수 max(x, y)를 호출
    max_xz := max(x, z) // 함수 max(x, z)를 호출

    fmt.Printf(&amp;quot;max(% d % d) = % d \n&amp;quot;, x, y max_xy)
    fmt.Printf(&amp;quot;max(% d % d) = % d \n&amp;quot;, x, z, max_xz)
    fmt.Printf(&amp;quot;max(% d % d) = % d \n&amp;quot;, y, z, max(y, z))  // 직접 호출해도 괜찮습니다.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 &lt;code&gt;max()&lt;/code&gt; 함수에는 2개의 인수가 있습니다. 인수의 형식은 모두 &lt;code&gt;int&lt;/code&gt;형 입니다.&lt;br /&gt;
첫 번째 인수 형식은 생략 할 수 있습니다.(즉 a, b int,나 a int, b int는 동일 합니다.)&lt;br /&gt;
선택은 개발자의 취향 입니다. 2개 이상의 동일한 형식의 반환값도 마찬가지 입니다.&lt;/p&gt;

&lt;h3 id=&#34;여러개의-반환-값:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;여러개의 반환 값&lt;/h3&gt;

&lt;p&gt;Go 언어는 C에 비해 향상적인 특징을 가지고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;함수가 한번에 여러개의 반환 값을 가질 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코드를 통해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

// A + B와 A * B를 반환 합니다
func SumAndProduct(A, B int) (int, int) {
    return A + B, A * B
}

func main() {
    x := 3
    y := 4

    xPLUSy, xTIMESy := SumAndProduct(x, y)

    fmt.Printf(&amp;quot;%d + %d = %d \n&amp;quot;, x, y xPLUSy)
    fmt.Printf(&amp;quot;%d * %d = %d \n&amp;quot;, x, y xTIMESy)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예제에서는 직접 2 개의 값을 반환 했습니다. 당연히 인수명으로 반환해도 상관 없습니다.&lt;br /&gt;
만약 함수가 export되는 함수라면(대문자로 시작) 가능한 한 반환 값에 이름을 붙이는 것을 권장 합니다.&lt;br /&gt;
왜냐면 이름없는 반환 코드보다 반환 변수명으로 반환하는 것이 코드의 가독성이 좋기 때문 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SumAndProduct(A, B int) (add int, Multiplied int) {
    add = A + B
    Multiplied = A * B
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;가변-인자:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;가변 인자&lt;/h3&gt;

&lt;p&gt;Go 함수는 가변 인자 기능을 지원하고 있습니다. 가변 인자를 받아들이는 함수는 불특정개의 인수를 처리 합니다.&lt;br /&gt;
이를 위해서 함수가 가변 인자를 처리할 수 있도록 특별한 선언을 해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func myfunc(arg ...int) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arg ...int&lt;/code&gt;는 Go에게 이 함수가 다수개의 인수를 받아들이는 함수라는 것을 알려 줍니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;주의할점은, 이렇게 선언한 다수개의 인수형식은 모두 &lt;code&gt;int&lt;/code&gt; 이여야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실제 가변인수는(&lt;code&gt;args&lt;/code&gt;) 함수 블록 내에서는 &lt;code&gt;int&lt;/code&gt;의 &lt;code&gt;slice&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for _,  n := range arg {
    fmt.Printf(&amp;quot;And the number is : %d \n&amp;quot;, n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;값-전달과-참조:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;값 전달과 참조&lt;/h3&gt;

&lt;p&gt;인수는 호출되는 함수에 전달될 때 &lt;strong&gt;실제값의 복사본&lt;/strong&gt;이 전달 됩니다.&lt;br /&gt;
호출되는 함수에서 인수에 어떠한 수정을 가해도 함수 호출시의 실제 인수는 아무런 변화가 없습니다.&lt;br /&gt;
값의 변화 상황은 단지 복사된 값 내에서 변할 뿐입니다. (값에 의한 전달)&lt;/p&gt;

&lt;p&gt;이것을 확인하는 예제를 하나 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

// 인수 + 1 을 하는 간단한 함수
func add1(a int) int {
    a = a + 1               // a의 값을 변경합니다.
    return a                // 새로운 값을 반환합니다.
}

func main() {
    x := 3

    fmt.Println(&amp;quot;x =&amp;quot;, x)      // &amp;quot;x = 3&amp;quot;으로 출력

    x1 := add1(x)              // add1(x)를 호출

    fmt.Println(&amp;quot;x + 1 =&amp;quot;, x1) // &amp;quot;x + 1 = 4&amp;quot;로 출력   
    fmt.Println(&amp;quot;x =&amp;quot;, x)      // &amp;quot;x = 3&amp;quot;으로 출력   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행해 보면, &lt;code&gt;add1()&lt;/code&gt; 함수를 호출한 후, &lt;code&gt;add1()&lt;/code&gt;에서 &lt;code&gt;a = a + 1&lt;/code&gt;을 수행하더라도, &lt;code&gt;x&lt;/code&gt;변수는&lt;br /&gt;
아무런 변화가 발생하지 않습니다. 이유는 매우 간단 합니다.&lt;br /&gt;
&lt;code&gt;add1()&lt;/code&gt;함수가 호출될 때, &lt;code&gt;add1()&lt;/code&gt; 함수가 받는 인수는 &lt;code&gt;x&lt;/code&gt; 자체가 아니라 &lt;code&gt;x의 복사본&lt;/code&gt;이기 때문 입니다.&lt;/p&gt;

&lt;p&gt;만약 실제 &lt;code&gt;x&lt;/code&gt; 자체를 전달하고 싶다면 어떻게 처리할까요? 이런 경우는 자주 발생 합니다.&lt;/p&gt;

&lt;p&gt;이 경우, 이른바 &lt;code&gt;**포인터**&lt;/code&gt;가 등장하게 됩니다. 변수는 메모리의 특정 위치에 존재하고 있다는 것을 이미 알고 있습니다.&lt;br /&gt;
실제로 변수를 수정한다는 것은 변수가 위치한 주소의 메모리의 내용을 수정하는 것입니다.&lt;br /&gt;
&lt;code&gt;add1()&lt;/code&gt; 함수가 &lt;code&gt;x&lt;/code&gt; 변수의 주소를 알고 있다면 &lt;code&gt;x&lt;/code&gt; 변수의 값을 직접 변경할 수 있습니다. 따라서 &lt;code&gt;x&lt;/code&gt;변수가 실제로&lt;br /&gt;
존재하는 주소값을, &lt;code&gt;&amp;amp;x&lt;/code&gt;형식으로 사용해서 함수에 전달하고, 함수의 매개변수 형식을 &lt;code&gt;int&lt;/code&gt;에서 포인터 변수인 &lt;code&gt;*int&lt;/code&gt;로 변경&lt;br /&gt;
합니다. 이제는 함수에서 &lt;code&gt;x&lt;/code&gt;의 값을 직접 변경할 수 있게 되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;이때에도 함수​​는 여전히 복사에 의한 인수를 전달합니다!!!
하지만 복사하는 대상이 포인터인 것입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음의 예제를 참조해서 보시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

// 인수 + 1 처리 함수
func add1(a *int) int {           // 주의하시기 바랍니다.
    *a = *a + 1                   // a의 값을 수정하고 있습니다.
    return *a                     // 새로운 값을 반환합니다.
}

func main() {
    x := 3

    fmt.Println(&amp;quot;x =&amp;quot;, x)         // &amp;quot;x = 3&amp;quot;으로 출력  

    x1 := add1(&amp;amp;x)                // add1(&amp;amp;x)를 호출하여 x의 주소를 전달

    fmt.Println(&amp;quot;x + 1 =&amp;quot;, x1)    // &amp;quot;x + 1 = 4&amp;quot;를 출력   
    fmt.Println(&amp;quot;x =&amp;quot;, x)         // &amp;quot;x = 4&amp;quot;를 출력
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이처럼 &lt;code&gt;x&lt;/code&gt;변수를 직접 수정할 수 있게 되었습니다. 이처럼 포인터를 전달해서 얻는 장점은 무엇일까요?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;포인터를 전달해서 여러 함수에서  같은 객체에 대해 작업을 수행 할 수 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;포인터 전달은 비교적 가볍 습니다. (8 바이트만 전달)메모리 주소만 전달하면 그만 입니다.&lt;br /&gt;
포인터를 사용해서 큰 구조체를 빠르게 전달할 수 있습니다. 만약 값으로 전달했다면, 상대적으로 더 많은 시스템 리소스&lt;br /&gt;
(메모리와 시간)를 매번 함수 호출할 때마다 소비하게 됩니다. 따라서 구조체와 같은 큰 자료형을 전달할 때 포인터를&lt;br /&gt;
사용하는 것이 현명한 선택입니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Go 언어의 &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;slice&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; 3가지 형식은 포인터를 사용하는 방식입니다.(포인터 참조형 입니다)&lt;br /&gt;
변수를 직접 전달할 수 있기 때문에 주소를 구해서 포인터를 전달할 필요가 없습니다.&lt;br /&gt;
하지만, 함수가 &lt;code&gt;slice&lt;/code&gt;의 길이를 변경하려면 주소를 구한 후 포인터를 전달해야 합니다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;defer:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;defer&lt;/h3&gt;

&lt;p&gt;Go 언어의 훌륭한 디자인 중 하나에는  &lt;code&gt;**지연(defer)**&lt;/code&gt; 문법이 있습니다.&lt;br /&gt;
함수에서 defer문을 여러 개 추가해서 사용할 수 있습니다.  함수가 끝까지 실행되었을 때 , defer문이 역순으로 실행된 후,&lt;br /&gt;
함수가 반환 됩니다. 이것은 특히 리소스를 오픈하는 작업을 하거나, 오류 발생에 대비한  롤백기능을 지원할때 요긴하게&lt;br /&gt;
사용될 수 있습니다. 이렇게 처리하지 않는다면, 리소스 및 메모리  누수 등의 문제를 일으킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;즉, 리소스를 다루는 프로그램의 경우는 다음의 코드와 같이 작성하고 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ReadWrite() bool {
    file.Open(&amp;quot;file&amp;quot;)
    
    if failureX {
        file.Close ()
    return false
    }

    if failureY {
        file.Close ()
        return false
    }

    file.Close ()
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드에는 중복 부분이 많이 보입니다. Go의 &lt;code&gt;defer&lt;/code&gt;는 바로 이러한 문제를 해결 합니다.&lt;br /&gt;
이 기능으로, 코드는 중복부분을 줄이는 기능뿐만 아니라 프로그램을 더 읽기 좋게 만들어 줍니다.&lt;br /&gt;
&lt;code&gt;defer&lt;/code&gt;키워드는 지정된 함수가 함수를 종료하기 직전에 호출되는 것을 보장해 주게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ReadWrite() bool {
    file.Open(&amp;quot;file&amp;quot;)
    defer file.Close()       // 지연문 호출 
    if failureX {
        return false
    }
    if failureY {
        return false
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 여러개의 &lt;code&gt;defer&lt;/code&gt;을 사용하는 경우는 &lt;code&gt;defer&lt;/code&gt;는 LIFO 형식으로 수행 됩니다.(역순 수행)&lt;br /&gt;
따라서 다음의 코드는 &lt;code&gt;4 3 2 1 0&lt;/code&gt;을 출력 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; 5; i++ {
    defer fmt.Printf(&amp;quot;% d&amp;quot;, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;값-형태로-함수사용:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;값 형태로 함수사용&lt;/h3&gt;

&lt;p&gt;Go언에서 함수또한 변수처럼 타입으로 처리할 수 있습니다. &lt;code&gt;type&lt;/code&gt; 키워드를 통해서 &lt;code&gt;함수 변수&lt;/code&gt;로 선언 합니다.&lt;br /&gt;
이것은 모두 동일한 인수와 동일한 값을 반환하는 하나의 함수 형식 변수 형태입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type typeName func(input1 inputType1, input2 inputType2[...]) (result1 resultType1[...])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수를 변수로 다룸으로써 어떠한 장점이 있을까요? 다음의 예를 참조하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type testInt func(int) bool     // 함수변수를 선언 합니다.

func isOdd(integer int) bool {
    if integer % 2 == 0 {
        return false
    }
    return true
}

func isEven(integer int) bool {
    if integer % 2 == 0 {
        return true
    }
    return false
}


func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f (value) {
            result = append (result, value)
        }
    }
    return result
}

func main() {
    slice := []int{1, 2, 3, 4, 5, 7}
    fmt.Println(&amp;quot;slice =&amp;quot;, slice)
    odd := filter(slice, isOdd)          // 함수 값 전달
    fmt.Println(&amp;quot;Odd elements of slice are :&amp;quot;, odd)
    even := filter(slice, isEven)        // 함수 값 전달
    fmt.Println(&amp;quot;Even elements of slice are :&amp;quot;, even)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;공유 인터페이스를 처리할 때 함수변수로 처리하면 매우 편리 합니다.&lt;br /&gt;
위의 예에서 &lt;code&gt;testInt&lt;/code&gt;라는 형식의 함수변수를 선언했습니다. 두 &lt;code&gt;filter()&lt;/code&gt; 함수의 인수와 반환 값은&lt;br /&gt;
&lt;code&gt;testInt&lt;/code&gt;의 형태와 동일하지만, 더 많은 로직을 제공 할 수 있습니다. 따라서 프로그램을 더 좋게 개선할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;panic와-recover:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;Panic와 Recover&lt;/h3&gt;

&lt;p&gt;Go언어는 Java와 같은 예외처리를 하지 않습니다. 즉, 예외를 던지지 않습니다.&lt;br /&gt;
대신 &lt;code&gt;panic&lt;/code&gt;과 &lt;code&gt;recover&lt;/code&gt; 기능을 사용 합니다. 반드시 기억 하시기 바랍니다.&lt;br /&gt;
&amp;gt; 이것은 최후의 수단으로 사용해야 한다는 것을.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;panic&lt;/code&gt;의 사용을 최대한 줄이시기 바랍니다. 이것은 매우 강력한 도구이나, 현명하게 사용하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Panic&lt;/code&gt;&lt;br /&gt;
내장 함수 입니다. 원래의 처리 흐름을 중단시킬 수 있습니다. 패닉이 발생한 로직으로 들어간 후  함수 &lt;code&gt;F&lt;/code&gt;가 &lt;code&gt;panic&lt;/code&gt;을&lt;br /&gt;
호출 합니다. 이 프로세스는 계속적으로 실행 됩니다. 일단 &lt;code&gt;panic&lt;/code&gt;이 &lt;code&gt;goroutine&lt;/code&gt;에서 발생하면 호출 된 함수가 모두 반환한&lt;br /&gt;
후 프로그램을 종료 합니다. 또는 직접&lt;code&gt;panic&lt;/code&gt;을 호출 합니다. 실행시 오류가 발생해도 처리할 수 있습니다.&lt;br /&gt;
예를 들어 배열의 경계를 넘어 액세스를 할 경우 등 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Recover&lt;/code&gt;&lt;br /&gt;
내장 함수 입니다. 에러 상황을 발생시키는 &lt;code&gt;goroutine&lt;/code&gt;을  복원 할 수 있습니다. &lt;code&gt;recover&lt;/code&gt;는 함수지연 내에서만 유효 합니다.&lt;br /&gt;
일반적으로 실행중에 &lt;code&gt;recover&lt;/code&gt;를 호출하면 &lt;code&gt;nil&lt;/code&gt;이  반환 됩니다. 즉, 아무런 효과도 없습니다.&lt;br /&gt;
만약 &lt;code&gt;goroutine&lt;/code&gt;에서 패닉이 발생하면, &lt;code&gt;recover&lt;/code&gt;를 호출하여 &lt;code&gt;panic&lt;/code&gt;의 입력 값을 보존한 후 정상적인 실행상태로&lt;br /&gt;
복원 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 예제를 통해서 어떻게 &lt;code&gt;panic&lt;/code&gt;이 작동하는지 알아보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var user = os.Getenv(&amp;quot;USER&amp;quot;)

func init() {
    if user == &amp;quot;&amp;quot; {
        panic(&amp;quot;no value for $USER&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 함수는 인수가 함수 실행시 &lt;code&gt;panic&lt;/code&gt;을 발생하는지를 검사 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func throwsPanic(f func()) (b bool) {
    defer func() {
        if x := recover(); x! = nil {
            b = true
        }
    }()
    f()           // 함수 f를 실행 합니다. 만약 f에서 panic이 발생되면 복원을 할 수 있습니다.
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;main-함수와-init-함수:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;&lt;code&gt;main&lt;/code&gt;함수와   &lt;code&gt;init&lt;/code&gt;함수&lt;/h3&gt;

&lt;p&gt;Go에는 2개의 함수가 예약되어 있습니다.&lt;br /&gt;
&lt;code&gt;init()&lt;/code&gt;함수(모든 &lt;code&gt;package&lt;/code&gt;에서 사용할 수 있습니다)와&lt;br /&gt;
&lt;code&gt;main()&lt;/code&gt;함수(&lt;code&gt;package main&lt;/code&gt;에서만 사용할 수 없습니다)입니다. 이 두 함수는 선언할때, 인수나 반환 값을 가지지 않습니다.&lt;br /&gt;
&lt;code&gt;package&lt;/code&gt;에서 여러개의 &lt;code&gt;init()&lt;/code&gt; 함수를 사용해도, 아무런 문제가 없습니다. 물론 가독성은 나빠지게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;에 한개의 &lt;code&gt;init()&lt;/code&gt;함수를 사용하길 강력히 추천합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go 프로그램은 자동으로 &lt;code&gt;init()&lt;/code&gt;함수와 &lt;code&gt;main()&lt;/code&gt;함수를 호출하기 때문에, 별도로 이 함수를 직접 호출 할 필요는 없습니다.&lt;br /&gt;
&lt;code&gt;package&lt;/code&gt;의 &lt;code&gt;init()&lt;/code&gt; 함수 사용은 선택적 입니다만,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;package main&lt;/code&gt;은 반드시 &lt;code&gt;main()&lt;/code&gt; 함수를 포함해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램 초기화 및 실행은 모두 &lt;code&gt;main&lt;/code&gt; 패키지에서 시작 됩니다. 만약 &lt;code&gt;main&lt;/code&gt; 패키지에서 다른 패키지의 기능을 사용할 경우,&lt;br /&gt;
컴파일시에 종속된 패키지를 가져 옵니다. 패키지에서 다른 여러 패키지를 동시에 가져오게될 경우에는 먼저 다른 패키지를 가져온 후,&lt;br /&gt;
이 패키지 안에있는 패키지 상수와 변수가 초기화 됩니다.&lt;br /&gt;
다음으로, &lt;code&gt;init()&lt;/code&gt;함수(있을 경우)가 실행되고, 마지막에 &lt;code&gt;main&lt;/code&gt; 함수가 실행되는 구조 입니다.&lt;br /&gt;
다음 그림에서 이런 실행 과정에 대해서 자세히 설명하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.3.init.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.6 main 함수를 사용하여 패키지 가져 오기 및 초기화 과정&lt;/p&gt;

&lt;h3 id=&#34;import:ecec97cf5f294358cffce75fc18e7e73&#34;&gt;import&lt;/h3&gt;

&lt;p&gt;Go 프로그램에서는 &lt;code&gt;import&lt;/code&gt; 명령으로 다른 패키지 파일을 가져 오는 경우가 종종 있습니다.&lt;br /&gt;
사용하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;fmt&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기처럼 &lt;code&gt;fmt&lt;/code&gt; 패키지를 가져오면, 코드에서 다음과 같은 방법으로 해당 패키지내의 함수를 호출 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(&amp;quot;hello world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fmt&lt;/code&gt; 패키지는 Go 언어의 표준 라이브러리 입니다. 사실 &lt;code&gt;$GOROOT&lt;/code&gt; 환경 변수에 지정된 디렉토리에 이 모듈이&lt;br /&gt;
실제로 존재 합니다. Go &lt;code&gt;import&lt;/code&gt;는 다음과 같은 두 가지 방법으로 자신이 쓴 패키지를 직접 추가 할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;상대 경로&lt;br /&gt;
&lt;code&gt;import &amp;quot;./model&amp;quot;&lt;/code&gt;&lt;br /&gt;
현재 파일과 같은 디렉토리에 있는 model 디렉토리. 그러나 이 방법으로 import는 추천하지 않습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;절대 경로&lt;br /&gt;
&lt;code&gt;import &amp;quot;shorturl/model&amp;quot;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;$gopath/src/shorturl/model&lt;/code&gt; 모듈을 추가 합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기에서는 &lt;code&gt;import&lt;/code&gt;에 대하여 일반적인 몇 가지 방법을 설명 했습니다.&lt;br /&gt;
이 방법 외에도 특수한 import가 몇가지 있습니다. 초보자에게는 낯설게 보이는 몇가지에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;도트(.)&lt;br /&gt;
간혹 다음과 같이 패키지를 가져 오는 방법을 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    import (
      . &amp;quot;fmt&amp;quot;
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 방식의 의미는 해당 패키지를 가져온 후에, 패키지의 함수를 호출 할 때 패키지 이름을 생략 할 수 있습니다.&lt;br /&gt;
   즉, &lt;code&gt;fmt.Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;로 호출하는 것을 &lt;code&gt;Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;와 같이 패키지이름을&lt;br /&gt;
   &lt;code&gt;.&lt;/code&gt; 사용해서 생략할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;별칭(Alias)&lt;br /&gt;
별칭은 이름에 대하여 동일한 별명을 사용해서 읽기 편하게 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
        f &amp;quot;fmt&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;별칭으로 사용할 경우 패키지 함수 호출 할 때 접두사를 별칭으로 사용할 수 있습니다.&lt;br /&gt;
   즉 &lt;code&gt;f.Println(&amp;quot;hello world&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;_ (언더바)&lt;br /&gt;
일반적으로 이해하기 힘든 경우에 속합니다. 다음의 import를 참조 하십시오.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;database / sql&amp;quot;
    _ &amp;quot;github.com/ziutek/mymysql/godrv&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;_(언더바)는 패키지를 가져 오기만 하는 것으로 패키지내의 함수를 직접 사용하는 것이 아니라,&lt;br /&gt;
이 패키지 안에 있는 &lt;code&gt;init() 함수만 호출&lt;/code&gt; 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/04] Struct</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/04-struct</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/04-struct</guid>
      <description>

&lt;h1 id=&#34;struct:dc81ca879119090b9c3afddc5e2ac033&#34;&gt;Struct&lt;/h1&gt;

&lt;p&gt;Go 언어는 C나 다른 언어와 마찬가지로 서로 다른 형태의 속성이나 필드의 컨테이너로 새로운 형태를&lt;br /&gt;
선언 할 수 있습니다. 예를 들어, 개인의 엔티티를 나타내는 &lt;code&gt;person&lt;/code&gt; 형을 새롭게 만들 수 있습니다.&lt;br /&gt;
이 엔티티는 속성을 가지고 있습니다. 성별과 나이 입니다. 이러한 형식은 &lt;code&gt;struct&lt;/code&gt; 이라고 합니다.&lt;br /&gt;
다음은 예제 코드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type person struct {
    name string
    age int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;struct 선언&lt;/code&gt;은 이렇게 간단하게 처리합니다.&lt;br /&gt;
위의 struct형은 2개의 필드를 가지고 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;string형의 name 필드는 사용자의 &lt;code&gt;이름&lt;/code&gt;을 저장하는 속성 입니다.&lt;/li&gt;
&lt;li&gt;int형 age 필드는 사용자의 &lt;code&gt;나이&lt;/code&gt;를 저장하는 속성 입니다.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 &lt;code&gt;struct&lt;/code&gt;이 어떻게 사용되는지를 코드를 통해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type person struct {
    name string
    age int
}

var P person                // P는 person형 변수입니다.

P.name = &amp;quot;Xenostream&amp;quot;      // &amp;quot;Xenostream&amp;quot;을 변수 P의 name 속성에 할당 합니다.
P.age = 25                 // &amp;quot;25&amp;quot;를 변수 P의 age 속성에 할당 합니다.
fmt.Printf(&amp;quot;The person &#39;s name is %s&amp;quot;, P.name)   // P의 name 속성에 액세스 합니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 방법외에도, 다른 여러 가지 선언 방법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;선언된 순서에 따라 초기화 합니다.&lt;br /&gt;
&lt;code&gt;P := person{&amp;quot;Tom&amp;quot;, 25}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;field : value&lt;/code&gt; 방법으로 초기화 합니다. 이 경우 순서는 임의로 설정 됩니다.&lt;br /&gt;
&lt;code&gt;P := person{age: 24, name: &amp;quot;Tom&amp;quot;}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;new()&lt;/code&gt; 함수를 통해서 포인터로 만들 수 있습니다. 이 P의 형태는 &lt;code&gt;*person&lt;/code&gt; 입니다.&lt;br /&gt;
&lt;code&gt;P := new(person)&lt;/code&gt;`&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음의 예제를 통해서 일반적인 struct의 사용법에 대해서 설명 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

// 새로운 형태(타입)를 선언 합니다.
type person struct {
    name string
    age int
}

// 두 사람의 나이를 비교 합니다. 나이가 큰 사람을 돌려주고, 나이 차이도 반환 합니다.
// struct도 값전달 방식으로 인수를 전달 합니다.
func Older(p1, p2 person) (person, int) {
    if p1.age &amp;gt; p2.age {              // p1과 p2의 두 사람의 나이를 비교합니다.
        return p1, p1.age - p2.age
    }
    return p2, p2.age - p1.age
}

func main() {
    var tom person

    // 초기 값을 할당 합니다.
    tom.name, tom.age = &amp;quot;Tom&amp;quot;, 18

    // 2 개의 필드를 명확히 초기화 합니다.
    bob := person{age: 25, name: &amp;quot;Bob&amp;quot;}

    // struct 정의의 순서대로 초기화 합니다.
    paul := person{&amp;quot;Paul&amp;quot;, 43}

    tb_Older, tb_diff := Older(tom, bob)
    tp_Older, tp_diff := Older(tom, paul)
    bp_Older, bp_diff := Older(bob, paul)

    fmt.Printf(&amp;quot;Of %s and %s %s is older by %d years \n&amp;quot;,
        tom.name, bob.name, tb_Older.name, tb_diff)

    fmt.Printf(&amp;quot;Of %s and %s %s is older by %d years \n&amp;quot;,
        tom.name, paul.name, tp_Older.name, tp_diff)

    fmt.Printf(&amp;quot;Of %s and %s %s is older by %d years \n&amp;quot;,
        bob.name, paul.name, bp_Older.name, bp_diff)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;struct-익명-필드:dc81ca879119090b9c3afddc5e2ac033&#34;&gt;struct 익명 필드&lt;/h3&gt;

&lt;p&gt;위에서 struct를 선언하는 방법에 대해서 설명 했습니다. 선언 할 때 필드이름과 형태가 각각 대응하고 있습니다.&lt;br /&gt;
사실 Go는 형태만 정의하는 것도 지원하고 있습니다. 이것은 &lt;code&gt;필드 이름을 쓰지 않는 방법&lt;/code&gt;으로, &lt;strong&gt;익명 필드&lt;/strong&gt;라고 합니다.&lt;br /&gt;
또는 &lt;code&gt;기본 제공 필드&lt;/code&gt;라고도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;익명 필드&lt;/code&gt;가 struct인 경우,이 struct가 가진 모든 필드는 숨겨지고, 현재 정의하고 있는 struct에 포함 됩니다.&lt;br /&gt;
예를 들어서 설명 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Human struct {
    name string
    age int
    weight int
}

type Student struct {
    Human          // 익명필드, 기본적으로 Student는 Human 모든 필드를 포함 할 수 있습니다.
    speciality string
}

func main() {
    // 학생 한 명을 초기화 합니다.
    mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, 120}, &amp;quot;Computer Science&amp;quot;}

    // 해당 필드에 액세스합니다.
    fmt.Println(&amp;quot;His name is&amp;quot;, mark.name)
    fmt.Println(&amp;quot;His age is&amp;quot;, mark.age)
    fmt.Println(&amp;quot;His weight is&amp;quot;, mark.weight)
    fmt.Println(&amp;quot;His speciality is&amp;quot;, mark.speciality)
    
    // 전공 정보를 수정 합니다.
    mark.speciality = &amp;quot;AI&amp;quot;
    fmt.Println(&amp;quot;Mark changed his speciality&amp;quot;)
    fmt.Println(&amp;quot;His speciality is&amp;quot;, mark.speciality)
    
    // 나이 정보를 수정 합니다.
    fmt.Println(&amp;quot;Mark become old&amp;quot;)
    mark.age = 46
    fmt.Println(&amp;quot;His age is&amp;quot;, mark.age)
    
    // 체중 정보를 수정합니다.
    fmt.Println( &amp;quot;Mark is not an athlet anymore&amp;quot;)
    mark.weight += 60
    fmt.Println(&amp;quot;His weight is&amp;quot;, mark.weight)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.4.student_struct.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.7 Student와 Human 상속&lt;/p&gt;

&lt;p&gt;Student가 age와 name 속성에 액세스 할 때, 마치 &lt;code&gt;자신의 필드인 것처럼 접근&lt;/code&gt;한 것을 볼 수 있습니다.&lt;br /&gt;
이것이 바로 &lt;code&gt;익명 필드&lt;/code&gt; 입니다. 이것으로 필드 상속을 구현 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;OOP언어에서 보다 간단하게 구현할 수 있지 않습니까? 여기에 더 멋진 방법도 있습니다.&lt;br /&gt;
student는 Human 필드 이름에서 액세스 할 수 있습니다.  아래의 코드를 참조 하십시오.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;mark.Human = Human{&amp;quot;Marcus&amp;quot;, 55, 220}
mark.Human.age -= 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;익명필드의 액세스 및 수정은 간단 합니다. struct 필드에는 Go언어의 모든 내장형과 자신이 정의한 모든형을&lt;br /&gt;
&lt;code&gt;익명 필드&lt;/code&gt;로 사내장해서 사용할 수 있습니다.  아래의 예를 참조하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Skills[] string

type Human struct {
    name string
    age int
    weight int
}

type Student struct {
    Human            // 익명 필드 struct
    Skills           // 익명 필드 내에서 정의 된 형. string slice
    int              // 기본 int형 필드
    speciality string
}

func main() {
    // 학생 Jane을 초기화 합니다.
    jane := Student{Human: Human{&amp;quot;Jane&amp;quot;, 35, 100}, speciality: &amp;quot;Biology&amp;quot;}
    
    // 해당 필드에 액세스 
    fmt.Println(&amp;quot;Her name is&amp;quot;, jane.name)
    fmt.Println(&amp;quot;Her age is&amp;quot;, jane.age)
    fmt.Println(&amp;quot;Her weight is&amp;quot;, jane.weight)
    fmt.Println(&amp;quot;Her speciality is&amp;quot;, jane.speciality)
    
    // skill 기능 필드를 수정 합니다.
    jane.Skills = []string{ &amp;quot;anatomy&amp;quot;}
    fmt.Println(&amp;quot;Her skills are&amp;quot;,jane.Skills)
    fmt.Println(&amp;quot;She acquired two new ones&amp;quot;)
    jane.Skills = append(jane.Skills, &amp;quot;physics&amp;quot;, &amp;quot;golang&amp;quot;)
    fmt.Println(&amp;quot;Her skills now are&amp;quot;jane.Skills)
    
    // 기본 int형 필드를 수정 합니다.
    jane.int = 3
    fmt.Println(&amp;quot;Her preferred number is&amp;quot;, jane.int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 같이, struct는 struct 익명필드뿐 만 아니라, 직접 정의한 형(Type)또는,  내장형도 익명필드로 처리&lt;br /&gt;
할 수 있습니다. 또한 해당 필드에 직접 함수를 실행 할 수 있습니다 (예를 들어 상기의 append() 입니다).&lt;/p&gt;

&lt;p&gt;만약 human에 phone이라는 필드가 있고, student에도 phone 이라는 필드가 있습니다.&lt;br /&gt;
이럴경우 어떤것이 사용되게 되는 것일 까요?&lt;/p&gt;

&lt;p&gt;Go는 이 문제를 쉽게 해결할 수 있습니다. 우선 외부가 먼저 액세스되기 때문에 &lt;code&gt;student.phone&lt;/code&gt;에 액세스 한 경우&lt;br /&gt;
st​​udent 내의 phone 필드에 액세스하고, human의 phone 필드에 액세스하지 않습니다.&lt;/p&gt;

&lt;p&gt;이처럼 익명 필드를 통해 &lt;code&gt;필드상속&lt;/code&gt;을 쉽게 처리 할 수 있습니다. 익명필드에 접근하고 싶다면 익명필드의 이름으로&lt;br /&gt;
액세스 할 수 있습니다. 아래의 예를 참조 하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Human struct {
    name string
    age int
    phone string         // Human 형이 가지는 필드
}

type Employee struct {
    Human               // 익명 필드 Human
    speciality string
    phone string        // 직원 phone 필드
}

func main() {
    Bob := Employee{Human{&amp;quot;Bob&amp;quot;, 34 &amp;quot;777-444-XXXX&amp;quot;}, &amp;quot;Designer&amp;quot;, &amp;quot;333-222&amp;quot;}
    fmt.Println(&amp;quot;Bob &#39;s work phone is :&amp;quot;, Bob.phone)
    
    // 만약 Human의 phone 필드에 액세스하는 경우
    fmt.Println(&amp;quot;Bob &#39;s personal phone is :&amp;quot;, Bob.Human.phone)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/05] Object Oriented</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/05-object-oriented</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/05-object-oriented</guid>
      <description>

&lt;h1 id=&#34;object-oriented:f3782d2577647ff9b9710d08a8be7b61&#34;&gt;Object Oriented&lt;/h1&gt;

&lt;p&gt;앞의 두 장에서 &lt;code&gt;함수&lt;/code&gt;와 &lt;code&gt;struct&lt;/code&gt;를 설명 했습니다. 함수를 struct의 필드로 처리할 수 있습니다.&lt;br /&gt;
이번장에서는 함수의 또 다른 형태에 대해서 설명 합니다.&lt;/p&gt;

&lt;p&gt;다른 객체지향프로그래밍 언어에서는 이 기능을 &lt;code&gt;method&lt;/code&gt;라고 부르는 기능 입니다.&lt;/p&gt;

&lt;h2 id=&#34;method:f3782d2577647ff9b9710d08a8be7b61&#34;&gt;method&lt;/h2&gt;

&lt;p&gt;사각형이라는 struct를 정의하고 이 사각형의 넓이를 구하는 프로그램을 작성하고 있다고 가정 하겠습니다.&lt;br /&gt;
먼저, 일반적인 사고방식으로 접근하면 다음과 같이 프로그래밍 하게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Rectangle struct {
    width, height float64
}

func area(r Rectangle) float64 {
    return r.width * r.height
}

func main() {
    r1 := Rectangle{12, 2}
    r2 := Rectangle{9, 4}
    fmt.Println(&amp;quot;Area of​​ r1 is :&amp;quot;, area(r1))
    fmt.Println(&amp;quot;Area of​​ r2 is :&amp;quot;, area (r2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상기의 코드로 사각형의 면적을 구할 수 있겠지만, &lt;code&gt;area()&lt;/code&gt; 함수는 Rectangle 구조체와 연관된 함수라고&lt;br /&gt;
볼 수 없습니다. Rectangle 객체(여기서는 r1, r2)들의 면적을 계산하는 함수에 그저 인수로 전달하고 있을 뿐입니다.&lt;/p&gt;

&lt;p&gt;이렇게 구현해도 상관없지만 여러가지 종류의 면적을 구할려면, 예를들어 사각형, 오각형, 다각형에 대한 면적을 구하는&lt;br /&gt;
상황이 발생한다면 어떻게 처리해야 할까요? 이런 경우의 해결책은 해당 처리 함수의 개수를 늘릴 수밖에 없습니다.&lt;br /&gt;
함수 이름 또한 개별적으로 중복되지 않게 준비해야 합니다. &lt;code&gt;area_rectangle, area_circle...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래의 그림은 타원 함수를 나타내고 있습니다. 이 함수는 struct에 속하지 않기(객체지향의 class에 속하지 않는)&lt;br /&gt;
때문에 struct 외부에 별도로 존재하고,  개념적으로도 어떤 struct과도 연관되지 않은 일반적인 함수 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.5.rect_func_without_receiver.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.8 함수와 struct의 관계도&lt;/p&gt;

&lt;p&gt;이런 함수류의 구현 방법에는 무리가 있습니다. 또한 개념적으로봐도, &amp;ldquo;면적&amp;rdquo;은 &amp;ldquo;형상&amp;rdquo;의 한 속성 입니다.&lt;br /&gt;
이 속성은 특정 형상과 연관되어 있습니다. 사각형의 가로, 세로와 같이 서로 뗄레야 뗄수 없는 존재인 것 입니다.&lt;/p&gt;

&lt;p&gt;이런 이유로 &lt;code&gt;method&lt;/code&gt;라는 개념이 생겨 났습니다. 즉, &lt;code&gt;method&lt;/code&gt;는 어떤 형태와 연관되어 존재한다 라는 의미 입니다.&lt;br /&gt;
&lt;code&gt;method&lt;/code&gt;선언 문법과 함수 선언 문법은 거의 동일 합니다. 단지,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;func&lt;/code&gt; 키워드 뒤에&lt;br /&gt;
receiver(method가 연관된 표시)를 추가해서 선언 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위에서 언급 한 형상 예제로 보면 &lt;code&gt;area()&lt;/code&gt; 함수(methos)는 형상(Rectangle)에 연관되어서 작동한다는 것입니다.&lt;br /&gt;
&lt;code&gt;Rectangle.area()&lt;/code&gt;의 의미는 Rectangle 형상에 &lt;strong&gt;연관된&lt;/strong&gt; area() 함수라는 의미 입니다.&lt;br /&gt;
Rectangle에 연관된 &lt;code&gt;메소드&lt;/code&gt;는 &lt;code&gt;구조체 외부에 선언&lt;/code&gt;하고, &lt;strong&gt;리시버를 통해서 해당 &lt;code&gt;구조체의 함수&lt;/code&gt;로 연관짓게 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;더 구체적으로 말하면, Rectangle은 length와 width &lt;code&gt;필드가 존재&lt;/code&gt;하고, 또한 area() &lt;code&gt;메소드&lt;/code&gt;도 존재 합니다.&lt;br /&gt;
이런 필드 및 메소드는 모두 Rectangle에 속한다 라는 의미 입니다.&lt;/p&gt;

&lt;p&gt;Go언어의 개발자 중 하나인 &lt;code&gt;Rob Pike&lt;/code&gt;의 말을 잠시 빌리면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A method is a function with an implicit first argument, called a receiver.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;method의 문법은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (r ReceiverType) funcName(parameters) (results)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전에 설명한 예제를 가지고 method를 설명하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math&amp;quot;
)

type Rectangle struct {
    width, height float64
}

type Circle struct {
    radius float64
}

func (r Rectangle) area() float64 {
    return r.width * r.height
}

func (c Circle) area() float64 {
    return c.radius * c.radius * math.Pi
}


func main() {
    r1 := Rectangle{12, 2}
    r2 := Rectangle{9, 4}
    c1 := Circle{10}
    c2 := Circle{25}

    fmt.Println(&amp;quot;Area of​​ r1 is :&amp;quot;, r1.area())
    fmt.Println(&amp;quot;Area of​​ r2 is :&amp;quot;, r2.area())
    fmt.Println(&amp;quot;Area of​​ c1 is :&amp;quot;, c1.area())
    fmt.Println(&amp;quot;Area of​​ c2 is :&amp;quot;, c2.area())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;method를 사용할 때는 다음의 몇가지를 주의하시기 바랍니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;method는 동일한 이름이라도 수신자가 다르면 method도 다릅니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;method는 수신자 필드에 액세스 할 수 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;method의 호출은 &lt;code&gt;.&lt;/code&gt; 통해 액세스 합니다. struct이 필드에 액세스하는 것과 동일 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://xenostream.github.io/post/go-web-programming/images/2.5.shapes_func_with_receiver_cp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림 2.9 다른 struct의 method는 다른 것입니다.&lt;/p&gt;

&lt;p&gt;위의 예에서 method area()는 각각 Rectangle과 Circle에 속한 메소드가 됩니다. 이때 Rectangle과 Circle이&lt;br /&gt;
리시버가 됩니다. 또한 area() 메소드는 Rectangle/Circle에 속하게 되고, 사용되어 집니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;method는 점선으로 표시하고 있습니다.
메소드의 리시버는 &lt;code&gt;값에 의한 전달&lt;/code&gt;이며, &lt;code&gt;참조&lt;/code&gt;가 아닙니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;리시버를 포인터로 처리해도 문제 없습니다. 차이점은 포인터는 리시버가 엔터티의 내용에 직접 수정할 수 있는 반면,&lt;br /&gt;
일반적인 방법의 리시버의 조작은 값의 복사본을 조작하는 것입니다. 원래 엔터티에 대한 수정이 발생하지 않는 것입니다.&lt;/p&gt;

&lt;p&gt;method는 struct에서만 사용할 수 있는 것일까요? &lt;strong&gt;당연히 아닙니다!!&lt;/strong&gt;&lt;br /&gt;
메소드는 사용자 정의형, 내장형, struct 등 &lt;code&gt;모든 형으로도 선언&lt;/code&gt;할 수 있습니다. 조금 헷갈리시는가요?&lt;br /&gt;
여기서 사용자 정의형이 struct 아닌가요? struct는 사용자 정의형 중에서도 비교적 특수한 형태의 타입일 뿐입니다.&lt;/p&gt;

&lt;p&gt;타입 선언은 다음과 같은 선언을 제공하고 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type typeName typeLiteral
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음의 예제는 &lt;code&gt;사용자 정의 타입&lt;/code&gt;을 선언하는 예제입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ages int

type money float32

type months map [string] int

m := months {
    &amp;quot;January&amp;quot;: 31
    &amp;quot;February&amp;quot;: 28,
    ...
    &amp;quot;December&amp;quot;: 31
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사용법을 아시겠습니까? 코드에 타입의 이름을 별도로 지정해서 가독성을 좋게 만드는것 일 뿐입니다.&lt;br /&gt;
실제로는 별칭을 정의해서 사용하는 것일 뿐입니다. C의 &lt;code&gt;typedef&lt;/code&gt;와 유사한 것으로, 상기의 예제에서는 ages는&lt;br /&gt;
int형과 같은 의미로 사용되는 것외에는 아무런 의미는 없습니다.&lt;/p&gt;

&lt;p&gt;다시, &lt;code&gt;method&lt;/code&gt; 설명으로 돌아와서, 사용자 정의형을 임의의 &lt;code&gt;method&lt;/code&gt;와 연관지을 수 있습니다.&lt;br /&gt;
다음은 이러한 기능을 하는 조금 복잡한 예제를 살펴 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

const (
    WHITE = iota          // 열거형 사용 
    BLACK
    BLUE
    RED
    YELLOW
)

type Color byte

type Box struct {
    width, height, depth float64
    color Color
}

type BoxList[] Box       // boxes 슬라이스 

func (b Box) Volume() float64 {
    return b.width * b.height * b.depth
}

func (b * Box) SetColor(c Color) {
    b.color = c
}

func (bl BoxList) BiggestColor() Color {
    v := 0.00
    k := Color(WHITE)
    for _,  b := range bl {
        if bv := b.Volume(); bv &amp;gt; v {
            v = bv
            k = b.color
        }
    }
    return k
}

func (bl BoxList) PaintItBlack() {
    for i,  _ := range bl {
        bl[i].SetColor(BLACK)
    }
}

func (c Color) String() string {
    strings := []string{ &amp;quot;WHITE&amp;quot;, &amp;quot;BLACK&amp;quot;, &amp;quot;BLUE&amp;quot;, &amp;quot;RED&amp;quot;, &amp;quot;YELLOW&amp;quot;}
    return strings [c]
}

func main() {
    boxes := BoxList {
                Box{4, 4, 4, RED}
                Box{10, 10, 1, YELLOW}
                Box{1, 1, 20, BLACK}
                Box{10, 10, 1, BLUE}
                Box{10, 30, 1, WHITE}
                Box{20, 20, 20, YELLOW}
    }

    fmt.Printf(&amp;quot;We have %d boxes in our set \n&amp;quot;, len(boxes))
    fmt.Println(&amp;quot;The volume of the first one is&amp;quot;, boxes[0].Volume(),  &amp;quot;cm³&amp;quot;)
    fmt.Println(&amp;quot;The color of the last one is&amp;quot;, boxes[len(boxes) -1].color.String())
    fmt.Println(&amp;quot;The biggest one is&amp;quot;, boxes.BiggestColor().String())

    fmt.Println(&amp;quot;Let &#39;s paint them all black&amp;quot;)
    boxes.PaintItBlack()
    fmt.Println(&amp;quot;The color of the second one is&amp;quot;, boxes[1].color.String())

    fmt.Println(&amp;quot;Obviously, now, the biggest one is&amp;quot;, boxes.BiggestColor().String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드는 &lt;code&gt;const&lt;/code&gt; 키워드로 몇개의 정수상수를 정의한 후, 몇가지의 &lt;code&gt;사용자 정의형&lt;/code&gt;을 선언하고 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Color는 byte의 별칭 입니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;struct Box를 선언 합니다. 3 개의 가로, 세로, 높이 필드와 색상 속성을 가지고 있습니다.&lt;/li&gt;
&lt;li&gt;slice BoxList을 선언 합니다. Box를 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음으로 사용자 정의형을 리시버로 method를 선언 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Volume()의 리시버를 Box로 선언 합니다. Box의 부피를 반환 합니다.&lt;/li&gt;
&lt;li&gt;SetColor(c Color)는 Box의 색을 c로 변경 합니다.&lt;/li&gt;
&lt;li&gt;BiggestColor()는 BoxList에 선언되어 있습니다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PaintItBlack()는 BoxList의 모든 Box의 색을 모두 검정색으로 변경 합니다.&lt;/li&gt;
&lt;li&gt;String()는 Color로 정의되어 있으며, Color의 구체적인 색을 돌려줍니다 (문자열 형식)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 코드를 문자로 표현하면 쉽게 생각됩니다. 문제를 해결할 경우 문제를 묘사한 후 해당 코드를 작성하여 제공 합니다.&lt;/p&gt;

&lt;h3 id=&#34;포인터-receiver:f3782d2577647ff9b9710d08a8be7b61&#34;&gt;포인터 receiver&lt;/h3&gt;

&lt;p&gt;그럼 여기서, SetColor 구현방법에 대해서 잠시 생각해 보겠습니다.&lt;br /&gt;
이 receiver는 Box의 포인터를 사용하고 있습니다. 즉, &lt;code&gt;*Box&lt;/code&gt;를 사용 하고 있습니다.&lt;br /&gt;
왜 &lt;code&gt;Box&lt;/code&gt;가 아닌 포인터를 사용하는 것일까요? SetColor를 선언하는 진짜 목적은 실제 Box의 색을 변경하는 것입니다.&lt;br /&gt;
만약 Box의 포인터를 전달하지 않았다면, SetColor가 받는 것은 사실 Box의 복사본인 것입니다.&lt;br /&gt;
즉, 메소드 내에서 색상을 변경하는 것은 Box의 복사본을 조작하는 것일뿐, 실제 Box에는 아무런 변화가 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;따라서 포인터를 전달해서 저장된 실제 값을 변경 해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서는 receiver를 함수선언의 첫번째로 기술했습니다. 이전의 함수 설명에서 값전달과 참조로 쉽게 처리 됩니다.&lt;br /&gt;
혹시 SetColor() 함수에서 다음과 같이 사용해야 하는게 아닐까? 라는 생각이 생길지도 모릅니다. &lt;code&gt;*b.Color = c&lt;/code&gt;&lt;br /&gt;
그런데 실제로는 &lt;code&gt;b.Color = c&lt;/code&gt;로 사용했습니다. 포인터에 저장된 실제 값을 읽을 수 있어야하기 때문 입니다.&lt;/p&gt;

&lt;p&gt;Go에서는 이 두 가지 방법 모두 맞습니다.&lt;br /&gt;
포인터를 사용해서 해당 필드에 액세스 한 경우(포인터에 아무런 필드가 없다고해도) Go는 포인터를 통해 그 값에&lt;br /&gt;
액세스하려는 것을 &lt;code&gt;이미&lt;/code&gt;&lt;code&gt;알고 있습니다. 생각 많은 개발자는 이렇게 생각할지도 모릅니다.     
PointItBlack에서 SetColor를 호출했을 때, 혹시&lt;/code&gt;(&amp;amp;bl[i]).SetColor(BLACK)&lt;code&gt;로 써야 하지 않을까? 라고 말입니다.     
SetColor()의 receiver는&lt;/code&gt;*Box&lt;code&gt;이지&lt;/code&gt;Box`가 아니니까요. &lt;strong&gt;하지만&lt;/strong&gt;, 두 가지 방법 모두 정상적으로 처리됩니다.&lt;br /&gt;
Go는 receiver가 포인터임을 이미 알고 있습니다. 그래서 내부적으로 자동으로 해석해서 처리해 주는 것입니다.&lt;/p&gt;

&lt;p&gt;만약 메소드의 receiver가 &lt;code&gt;*T&lt;/code&gt;라면, &lt;code&gt;T&lt;/code&gt;형 엔티티 변수 V에서 이 메소드를 호출 할 수 있습니다.&lt;br /&gt;
이때 &lt;code&gt;&amp;amp;V&lt;/code&gt;를 통해서 메소드를 호출 할 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;마찬가지로,&lt;/p&gt;

&lt;p&gt;만약 메소드의 receiver가 &lt;code&gt;T&lt;/code&gt;라면, &lt;code&gt;*T&lt;/code&gt;형 변수 P에서 이 메소드를 호출 할 수 있습니다.&lt;br /&gt;
이때 &lt;code&gt;*P&lt;/code&gt;를 사용하여 메소드를 호출 할 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;결과적으로 호출하고있는 메소드가 포인터 메소드인지는 신경 쓸 필요가 없습니다. Go는 당신이 시도하고있는 모든 것을&lt;br /&gt;
이미 알고있는 것입니다. C/C++ 프로그램을 작성해본 개발자라면, 이점이 아주 유용할 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;method-상속:f3782d2577647ff9b9710d08a8be7b61&#34;&gt;method 상속&lt;/h3&gt;

&lt;p&gt;이전 장에서는 &lt;code&gt;익명 필드&lt;/code&gt;를 통한 필드의 &lt;code&gt;상속&lt;/code&gt;에 대해서 배웠습니다. 마찬가지로!!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;method도 상속 할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;만약 익명필드가 한개의 메소드를 구현하는 경우이 익명 필드를 포함해서 sturct에서 메소드를 호출 할 수 있습니다.&lt;br /&gt;
다음의 예제를 통해서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Human struct {
    name string
    age int
    phone string
}

type Student struct {
    Human            // 익명 필드
    school string
}

type Employee struct {
    Human             // 익명 필드
    company string
}

// human에서 메소드를 정의
func (h * Human) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s \n&amp;quot;, h.name, h.phone)
}

func main() {
    mark := Student{Human{&amp;quot;Mark&amp;quot;, 25 &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;}
    sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45 &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;}

    mark.SayHi()
    sam.SayHi()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-재-작성-methos-override:f3782d2577647ff9b9710d08a8be7b61&#34;&gt;method 재 작성(Methos Override)&lt;/h3&gt;

&lt;p&gt;위의 예에서 만약 Employee에서 SayHi() 함수를 구현하려면 어떻게하면 좋을까요?  간단합니다.&lt;br /&gt;
익명필드의 충돌처리와 같은 이치로, Employee에서도 메소드를 &lt;code&gt;재 정의&lt;/code&gt; 할 수 있습니다.&lt;br /&gt;
익명 필드를 &lt;code&gt;재 정의&lt;/code&gt; 방법은 아래의 예를 참조 하십시오.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Human struct {
    name string
    age int
    phone string
}

type Student struct {
    Human           // 익명 필드
    school string
}

type Employee struct {
    Human           // 익명 필드
    company string
}

// Human에 method를 정의
func (h *Human) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s \n&amp;quot;, h.name, h.phone)
}

// Employee의 method로 Human의 method를 재정의 
func (e * Employee) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s, I work at %s. Call me on %s \n&amp;quot;, e.name,
            e.company, e.phone) // 2줄로 나눠서 작성해도 됩니다!!!
}

func main() {
    mark := Student{Human{&amp;quot;Mark&amp;quot;, 25 &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;}
    sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45 &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;}

    mark.SayHi()
    sam.SayHi()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드에서 본 것과 같이 &lt;code&gt;Go언어&lt;/code&gt;는 아주 유연하게 디자인 되어 있습니다.&lt;br /&gt;
이런 지식을 토대로 기본적인 객체 지향 프로그램을 설계 할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Go객체지향은 이렇게 간단히 구현 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;public/private 라는 키워드는 필요하지 않습니다. 대문자와 소문자를 사용해서 처리합니다.&lt;br /&gt;
즉, 대문자로 시작하면 외부에 공개하고, 소문자로 시작하면 비공개입니다. 메서드도 동일한 규칙이 적용됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/06] Interface</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/06-interface</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/06-interface</guid>
      <description>

&lt;h1 id=&#34;interface:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;Interface&lt;/h1&gt;

&lt;h2 id=&#34;interface-1:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;interface&lt;/h2&gt;

&lt;p&gt;Go언어에는 아주 섬세하게 설계된 &lt;code&gt;interface&lt;/code&gt;라는 것이 있습니다.&lt;br /&gt;
이 기능은 객체지향 프로그래밍과 효율적인 프로그램 구성시에 매우 편리하게 사용 됩니다.&lt;br /&gt;
이 장 다읽은 후에는 Go언어의 &lt;code&gt;interface&lt;/code&gt;의 획기적인 디자인 방식에 감탄하게 될 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;interface란-무엇인가:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;interface란 무엇인가?&lt;/h3&gt;

&lt;p&gt;간단하게 말하면, &lt;code&gt;interface는 method의 조합&lt;/code&gt; 입니다. interface를 통해 개체의 행동을 정의 할수 있습니다.&lt;br /&gt;
이전 장의 마지막 예제에서 Student와 Employee 객체 모두 SayHi() 메소드를 가지고 있었습니다.&lt;br /&gt;
그들의 내부 처리 방식은 다르지만, 그것은 중요하지 않습니다. 중요한 것은 그들 모두 &lt;code&gt;say hi&lt;/code&gt;라고 말한다는 것입니다.&lt;/p&gt;

&lt;p&gt;여기에, 계속 더 확장 해 보겠습니다. Student와 Employee에서 또 다른 메소드 &lt;code&gt;Sing()&lt;/code&gt;을 작성 합니다.&lt;br /&gt;
Student에는 BorrowMoney() 메소드를 추가하고,  Employee는 SpendSalary()를 추가 하겠습니다.&lt;/p&gt;

&lt;p&gt;Student에는 총 3가지 메소드가 존재 합니다. &lt;code&gt;SayHi(), Sing(), BorrowMoney()&lt;/code&gt; 입니다.&lt;br /&gt;
Employee는 &lt;code&gt;SayHi(), Sing(), SpendSalary()&lt;/code&gt; 3가지 메소드 입니다.&lt;/p&gt;

&lt;p&gt;위와 같은 조합에서 interface(개체 Student와 Employee에 추가)를 사용할 수 있습니다.&lt;br /&gt;
예를 들어, Student와 Employee에서 &lt;code&gt;모두&lt;/code&gt; interface인 SayHi()와 Sing()을 &lt;code&gt;구현&lt;/code&gt;하고 있습니다.&lt;br /&gt;
이 두 개체는 &lt;code&gt;interface 형&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;Employee에서 interface는  SayHi(), Sing() 입니다. BorrowMoney는 구현하지 않습니다.&lt;br /&gt;
Employee는 BorrowMoney() 메소드를 구현하지 않기 때문입니다.&lt;/p&gt;

&lt;h3 id=&#34;interface-형:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;interface 형&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;interface 형&lt;/code&gt;은  메소드의 집합을 선언 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;만약 어떤 객체가 인터페이스에 선언된 모든 메소드를 구현하면, 이 객체는 이 인터페이스를 구현한 것입니다.&lt;br /&gt;
자세한 문법은 다음의 예제를 참고 하십시오.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type Human struct {
    name string
    age int
    phone string
}

type Student struct {
    Human            // 익명필드 Human
    school string
    loan float32
}

type Employee struct {
    Human            // 익명 필드 Human
    company string
    money float32
}

// Human 객체에 SayHi 메서드를 구현합니다.
func (h *Human) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s \n&amp;quot;, h.name, h.phone)
}

// Human 객체에 Sing 메소드를 구현합니다.
func (h *Human) Sing(lyrics string) {
    fmt.Println(&amp;quot;La la, la la la, la la la la la ...&amp;quot;, lyrics)
}

// Human 객체에 Guzzle 메소드를 구현합니다.
func (h *Human) Guzzle(beerStein string) {
    fmt.Println(&amp;quot;Guzzle Guzzle Guzzle ...&amp;quot;, beerStein)
}

// Employee는 Human의 SayHi 메서드를 재정의 합니다.
func (e *Employee) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s, I work at %s. Call me on %s \n&amp;quot;, e.name,
        e.company, e.phone)            //여러 줄에 연속 기록해도 괜찮습니다.   
}

// Student는 BorrowMoney() 메소드를 구현 합니다.
func (s *Student) BorrowMoney(amount float32) {
    s.loan += amount       
}

// Employee는 SpendSalary() 메소드를 구현 합니다.
func (e *Employee) SpendSalary(amount float32) {
    e.money -= amount      
}

// interface를 정의 합니다.
type Men interface {
    SayHi()
    Sing(lyrics string)
    Guzzle(beerStein string)
}

type YoungChap interface {
    SayHi()
    Sing(song string)
    BorrowMoney(amount float32)
}

type ElderlyGent interface {
    SayHi()
    Sing(song string)
    SpendSalary(amount float32)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드를 통해서 알수 있듯이,  interface라는 것은 모든 객체에서 구현할 기능임을 알 수 있습니다.&lt;br /&gt;
Men interface는 Human, Student 및 Employee에 의해 구현 됩니다.&lt;br /&gt;
예를 들어 Student는 Men과 YoungChap 두개의 &lt;code&gt;interface를 구현&lt;/code&gt;하게 됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로, &lt;code&gt;모든 종류를 처리할 수 있는 빈 interface&lt;/code&gt;(여기에서는 interface{}라고 정의 합시다)를&lt;br /&gt;
구현하고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;빈 인터페이스는 &lt;code&gt;0개&lt;/code&gt;의 메소드가 포함 된 interface 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;interface-값:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;interface 값&lt;/h3&gt;

&lt;p&gt;interface에는 실제 어떤 값이 존재 할까요? &lt;code&gt;interface 변수&lt;/code&gt;를 선언하면,  이 변수에는 interface 유형의&lt;br /&gt;
모든 객체를 저장할 수 있습니다. 위의 예제로 표현하면, Men interface 변수 m을 선언 했습니다.&lt;br /&gt;
&lt;code&gt;m 변수&lt;/code&gt;는 Human, Student 또는 Employee 값을 저장할 수 있게 된다는 의미 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m&lt;/code&gt; 은 3 가지 형태를 가질 수있는 객체이므로, &lt;code&gt;Men형&lt;/code&gt;의 요소를 포함하는 &lt;code&gt;slice&lt;/code&gt;를 정의 할 수 있습니다.&lt;br /&gt;
이 slice는 Men 인터페이스의 모든 구조의 객체를 할당 할 수 있습니다. 이 slice와 원래의 slice에는 차이가 있습니다.&lt;br /&gt;
다음의 예를 살펴 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

type Human struct {
    name string
    age int
    phone string
}

type Student struct {
    Human         // 익명 필드
    school string
    loan float32
}

type Employee struct {
    Human         // 익명 필드
    company string
    money float32
}

// Human에 SayHi() 메서드를 구현 합니다.
func (h Human) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s \n&amp;quot;, h.name, h.phone)
}

// Human에 Sing() 메소드를 구현 합니다.
func (h Human) Sing(lyrics string) {
    fmt.Println(&amp;quot;La la la la ...&amp;quot;, lyrics)
}

// Employee는 Human의 SayHi() 메서드를 재작성 합니다.
func (e Employee) SayHi() {
    fmt.Printf(&amp;quot;Hi, I am %s, I work at %s. Call me on %s \n&amp;quot;, e.name,
        e.company, e.phone)
}

// Interface Men은 Human, Student 및 Employee로 구현 됩니다.
// 이 3 가지 형태는 다음의 두 가지 메소드를 구현했기 때문 입니다.
type Men interface {
    SayHi()
    Sing(lyrics string)
}

func main() {
    mike := Student{Human{&amp;quot;Mike&amp;quot;, 25 &amp;quot;222-222-XXX&amp;quot;}, &amp;quot;MIT&amp;quot;0.00}
    paul := Student{Human{&amp;quot;Paul&amp;quot;, 26 &amp;quot;111-222-XXX&amp;quot;}, &amp;quot;Harvard&amp;quot;100}
    sam := Employee{Human{&amp;quot;Sam&amp;quot;, 36 &amp;quot;444-222-XXX&amp;quot;}, &amp;quot;Golang Inc.&amp;quot;1000}
    tom := Employee{Human{&amp;quot;Tom&amp;quot;37 &amp;quot;222-444-XXX&amp;quot;}, &amp;quot;Things Ltd.&amp;quot;5000}

    // Men 유형의 i 변수를 선언 합니다.
    var i Men

    // i에는 Student를 저장할 수 있습니다.
    i = mike
    fmt.Println(&amp;quot;This is Mike, a Student :&amp;quot;)
    i.SayHi()
    i.Sing(&amp;quot;November rain&amp;quot;)

    // i에는 Employee를 저장할 수도 있습니다.
    i = tom
    fmt.Println(&amp;quot;This is Tom, an Employee :&amp;quot;)
    i.SayHi()
    i.Sing(&amp;quot;Born to be wild&amp;quot;)

    // Men형의 슬라이스를 정의 합니다.
    fmt.Println(&amp;quot;Let &#39;s use a slice of Men and see what happens&amp;quot;)
    x := make([]Men 3)
    
    //이 3 개는 모두 다른 요소이지만, 같은 인터페이스를 구현하고 있습니다.
    x[0], x[1], x[2] = paul, sam, mike

    for _,  value := range x {
        value.SayHi()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 코드를 통해서 interface는 &lt;code&gt;**메서드의 집합을 추상화**&lt;/code&gt;한 것임을 알 수 있습니다.&lt;br /&gt;
Go는 interface를 구현하는 &lt;code&gt;duck-typing&lt;/code&gt;을 제공 합니다. 즉 &amp;ldquo;오리처럼 달리는 모습과 오리처럼 수영하고,&lt;br /&gt;
오리같이 울고, 오리처럼 소리를 낸다면, 이 새는 오리다&amp;rdquo; 라는 것입니다.&lt;/p&gt;

&lt;h3 id=&#34;빈-interface:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;빈 interface&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;빈 interface&lt;/code&gt; (&lt;strong&gt;interface {}&lt;/strong&gt;)는 아무런 메소드도 포함하지 않은 인터페이스 입니다.&lt;br /&gt;
이 인터페이스는 모든 형태를 처리할 수 있는 근원적인 interface를 구현하고 있습니다.&lt;br /&gt;
빈 interface 자체적으로는 아무 의미도 없습니다.(어떤 메소드도 포함되어 있지 않기 때문에)&lt;br /&gt;
이 방식은 어떠한 형태의 수치를 저장할지 모를 경우에 아주 유용하게 사용할 수 있습니다.&lt;br /&gt;
이것은 어떤 형태의 수치도 저장할 수 있는 구조이기 때문에 &lt;code&gt;C 언어의 void * 형태&lt;/code&gt;와 비슷하게 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// a를 빈 인터페이스로 정의
var a interface {}
var i int = 5
s := &amp;quot;Hello world&amp;quot;
// a는 모든 유형의 값을 저장할 수 있습니다.
a = i
a = s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수가 &lt;code&gt;interface {}&lt;/code&gt;를 인수로 취하면 &lt;code&gt;모든 형식의 값&lt;/code&gt;을 인수로 취할 수 있습니다.&lt;br /&gt;
만약 함수가 interface {}를 반환하면 모든 형식의 값을 반환 할 수 있습니다. 매우 편리 합니다!&lt;/p&gt;

&lt;h3 id=&#34;interface-함수의-인수:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;interface 함수의 인수&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;interface 변수&lt;/code&gt;는 이 interface 형식의 개체를 가질 수 있습니다.&lt;br /&gt;
&lt;code&gt;interface 인수&lt;/code&gt;를 선언하면 &lt;code&gt;함수에 모든 형태의 인수&lt;/code&gt;를 받게 처리 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 보겠습니다. &lt;code&gt;fmt.Println()&lt;/code&gt;은 지금까지 가장 자주 사용했던 함수입니다.&lt;br /&gt;
하지만 이 함수는 어떤 형태의 데이터를 받아도 처리했던것을 유심히 보셨나요?&lt;br /&gt;
&lt;code&gt;fmt&lt;/code&gt; 패키지의  소스 파일을 살펴보면 이런 방식으로 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Stringer interface {
    String () string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;즉, String 메소드를 가지는 모든 형태가 fmt.Println() 의해 호출 될 수있는 것입니다. 시험해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
)

type Human struct {
    name string
    age int
    phone string
}

//이 메소드를 사용해 Human에 fmt.Stringer을 구현 합니다.
func (h Human) String () string {
    return &amp;quot;이름:&amp;quot;+ h.name + &amp;quot;-&amp;quot;+ strconv.Itoa(h.age) + &amp;quot;years - ✆&amp;quot;+ h.phone + &amp;quot;❱&amp;quot;
}

func main () {
    Bob := Human{&amp;quot;Bob&amp;quot;, 39 &amp;quot;000-7777-XXX&amp;quot;}
    fmt.Println(&amp;quot;This Human is :&amp;quot;Bob)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 Box의 예제를 생각해 보겠습니다. Color 구조체도 메소드를 하나 정의하고 있습니다. String 입니다.&lt;br /&gt;
사실 이것도 &lt;code&gt;fmt.Stringer()&lt;/code&gt;라는 interface를 구현하고 있는 것입니다. 즉, 어떤 형태로도 fmt 패키지를 이용해서&lt;br /&gt;
출력 시키려고 한다면, &lt;code&gt;Stringer 인터페이스를 구현&lt;/code&gt;해야 합니다. 만약 이 인터페이스를 구현하지 않으면&lt;br /&gt;
fmt는 기본 방식으로 출력 하게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 같은 기능을 구현 합니다.
fmt.Println(&amp;quot;The biggest one is&amp;quot;, boxes.BiggestsColor() String ())
fmt.Println(&amp;quot;The biggest one is&amp;quot;, boxes.BiggestsColor())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;주: error 인터페이스 객체(Error () string 객체를 구현)를 구현 합니다. fmt를 사용하여 출력을 할 경우 Error() 메소드가&lt;br /&gt;
호출 됩니다. 따라서 String() 메소드를 재정의 할 필요가 없습니다.&lt;/p&gt;

&lt;h3 id=&#34;interface-변수를-저장하는-형식:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;interface 변수를 저장하는 형식&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;interface 변수&lt;/code&gt;에는 모든 형태의 데이터를 저장할 수있는 것을 배웠습니다. (interface를 구현해서 처리 하고 있습니다).&lt;br /&gt;
하지만, 변수에 실제로 저장되어있는 것이 어떤 형태의 객체인지 알 수 있는 방법은 없을까요? 현재 두 가지 방법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Comma-ok 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 언어의 문법에는 변수가 어떤 형태인지를 직접 판단하는 방법이 있습니다.&lt;br /&gt;
&lt;code&gt;value, ok = element(T)&lt;/code&gt; 에서 value는 변수의 값을 가지게 됩니다. ok는 bool 형식 입니다.&lt;br /&gt;
element는 &lt;code&gt;interface 변수&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;만약 element에 T형의 데이터가 존재하면 ok는 true가 반환 됩니다. 그렇지 않으면 false가 반환 됩니다.&lt;/p&gt;

&lt;p&gt;예제를 통해서 상세하게 이해하고 가겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
)

type Element interface {}
type List [] Element

type Person struct {
    name string
    age int
}

// String 메소드를 정의 합니다. fmt.Stringer을 구현 합니다.
func (p Person) String () string {
    return &amp;quot;(name :&amp;quot;+ p.name + &amp;quot;- age :&amp;quot;+ strconv.Itoa(p.age) + &amp;quot;years)&amp;quot;
}

func main () {
    list := make(List 3)
    list [0] = 1               // int
    list [1] = &amp;quot;Hello&amp;quot;         // string
    list [2] = Person{&amp;quot;Dennis&amp;quot;, 70}

    for index, element := range list {
        if value, ok := element(int); ok {
            fmt.Printf(&amp;quot;list [%d] is an int and its value is %d \n&amp;quot;, index, value)
        } else if value, ok := element(string); ok {
            fmt.Printf(&amp;quot;list [%d] is a string and its value is %s \n&amp;quot;, index, value)
        } else if value, ok := element(Person); ok {
            fmt.Printf(&amp;quot;list [%d] is a Person and its value is %s \n&amp;quot;, index, value)
        } else {
            fmt.Println(&amp;quot;list [%d] is of a different type&amp;quot;, index)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;매우 간단 합니다. 이전 제어문에서 설명한대로 여러개의 if에서 변수를 초기화할 수 있습니다.&lt;br /&gt;
또한 분기 처리가 증가하면 증가할수록, if-else의 수도 증가하는 것을 기억할 것입니다.&lt;/p&gt;

&lt;p&gt;다음은 &lt;code&gt;switch&lt;/code&gt;를 설명 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;switch 테스트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;코드 예제를 보는 것이 빠르겠습니다. 위의 코드를 다시 처리 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
)

type Element interface {}
type List [] Element

type Person struct {
    name string
    age int
}

// 프린트
func (p Person) String () string {
    return &amp;quot;(name :&amp;quot;+ p.name + &amp;quot;- age :&amp;quot;+ strconv.Itoa(p.age) + &amp;quot;years)&amp;quot;
}

func main () {
    list := make (List 3)
    list [0] = 1                     // int
    list [1] = &amp;quot;Hello&amp;quot;               // string
    list [2] = Person{&amp;quot;Dennis&amp;quot;, 70}

    for index, element := range list {
        switch value := element(type) {
        case int:
            fmt.Printf(&amp;quot;list [%d] is an int and its value is %d \n&amp;quot;, index, value)
        case string:
            fmt.Printf(&amp;quot;list [%d] is a string and its value is %s \n&amp;quot;, index, value)
        case Person:
            fmt.Printf(&amp;quot;list [%d] is a Person and its value is %s \n&amp;quot;, index, value)
        default:
            fmt.Println(&amp;quot;list [%d] is of a different type&amp;quot;, index)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 강조하고 싶은 것은 &lt;code&gt;element (type)&lt;/code&gt;문법은 switch의 외부에서는 사용할 수 없다는 것입니다.&lt;br /&gt;
만약 switch 외부에서 이런 형태를 판단하려면 &lt;code&gt;comma-ok&lt;/code&gt; 방식을 사용 하십시오.&lt;/p&gt;

&lt;h3 id=&#34;내장-interface:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;내장 interface&lt;/h3&gt;

&lt;p&gt;Go 언어의 가장 매력적인 것은 바로 기본적인 논리처리 문법 입니다. Struct을 배울때 &lt;code&gt;익명 필드&lt;/code&gt;가 우아한 처리 중 하나입니다.&lt;br /&gt;
이와 유사한 논리로 interface에 도입하면 더 완벽하게 됩니다.&lt;br /&gt;
만약 interface1이 interface2 내장 필드이면 interface2는 암묵적으로 interface1의 메소드를 포함 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;container/heap&lt;/code&gt; 패키지에서 이런 정의가있는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Interface interface {
    sort.Interface         // 기본 제공 필드 sort.Interface
    Push(x interface {})   // Push method to push elements into the heap
    Pop() interface {}     // Pop elements that pops elements from the heap
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sort.Interface는 사실 기본 제공 필드 입니다. sort.Interface의 모든 메소드를 암시 적으로 포함 합니다.&lt;/p&gt;

&lt;p&gt;즉 다음의 세 가지 방법입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less returns whether the element with index i should sort
    // before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또 다른 예는 io 패키지 안에있는 &lt;code&gt;io.ReadWriter&lt;/code&gt;입니다.&lt;br /&gt;
이 패키지에는 io 패키지의 Reader와 Writer, 두개의 interface를 포함하고 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// io.ReadWriter
type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;리플렉션:6fecba8e3bce6ef1e9520231bf44d186&#34;&gt;리플렉션&lt;/h3&gt;

&lt;p&gt;Go는 리플렉션을 구현하고 있습니다. 리플렉션은 프로그램의 런타임 상태를 검사 할 수 있습니다.&lt;br /&gt;
우리가 일반적으로 사용하고있는 패키지는 &lt;code&gt;reflect 패키지&lt;/code&gt;&lt;code&gt;입니다. reflect 패키지를 어떻게 사용하는지는&lt;/code&gt;공식 문서`에 자세한 원리가&lt;br /&gt;
설명되어 있습니다. &lt;a href=&#34;http://golang.org/doc/articles/laws_of_reflection.html&#34;&gt;laws of reflection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;reflect를 사용하려면 3단계로 처리를 나눌 수 있습니다. 간단하게 설명 합니다.&lt;/p&gt;

&lt;p&gt;reflect 형태의 값(이 값은 빈 인터페이스를 통해서 구현하고 있습니다.) 먼저 reflect 객체로 변환해야 합니다.&lt;br /&gt;
(reflect.Type 또는 reflect.Value입니다.상황에 따라 각가의 함수를 호출 합니다.)&lt;br /&gt;
이 두 가지를 얻을 수있는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;t := reflect.TypeOf(i)   // 원래 데이터를 가져옵니다. t를 통해 형식 정의된 모든 요소를​​ 검색 할 수 있습니다.
v := reflect.ValueOf(i)  // 실제 값을 가져옵니다. v를 통해 저장되고있는 값을 얻을 수 있습니다. 값을 변경할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reflect 객체로 변환 한 후 어떠한 작업을 할 수 있습니다. 즉, reflect 객체를 이에 대응하는 값으로 변환하는 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tag := t.Elem().Field(0).Tag       // struct에서 정의 된 태그를 취득 합니다.
name := v.Elem().Field(0).String() // 첫 번째 필드에 저장되어있는 값을 얻을 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reflect 값을 검색하여 해당 형식과 값을 반환 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println(&amp;quot;type :&amp;quot;, v.Type())
fmt.Println(&amp;quot;kind is float64 :&amp;quot;, v.Kind () == reflect.Float64)
fmt.Println(&amp;quot;value :&amp;quot;, v.Float())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막으로 Reflect 필드는 값을 수정할 수 있어야 합니다. 이것은 앞에서 배운 &lt;code&gt;값 전달&lt;/code&gt;과 &lt;code&gt;참조&lt;/code&gt;와 같은 방법 입니다.&lt;br /&gt;
리플렉션 필드를 읽고/쓰는 것은 다음과 같이 사용하면 오류가 발생하는 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 해당하는 값을 변경하려면 이런 방식으로 사용해야 합니다 .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x float64 = 3.4
p := reflect.ValueOf(&amp;amp;x)
v := p.Elem()
v.SetFloat(7.1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;리플렉션에 대해서 간단히 설명했다고 하지만, 실제적인 이해는 프로그래밍에서 직접 이해해 나가는 수 밖에 없습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Web Programming: [02/07] Concurrency</title>
      <link>http://xenostream.github.io/2016/02/go-web-programming-02/07-concurrency</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://xenostream.github.io/2016/02/go-web-programming-02/07-concurrency</guid>
      <description>

&lt;h1 id=&#34;concurrency:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;Go언어를 &lt;code&gt;21세기의 C언어&lt;/code&gt;라는 사람도 있습니다. Go 언어는 설계가 간단하고, 21세기 환경에서 가장 중요한 것은&lt;br /&gt;
멀티 스레드이기 때문 입니다. Go는 언어차원에서 멀티 스레드를 지원하고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;goroutine:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;goroutine&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;goroutine은 &lt;code&gt;Go 멀티 스레드의 핵심&lt;/code&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;goroutine은 실제로 처음부터 끝까지 &lt;code&gt;스레드&lt;/code&gt;입니다. 그러나 스레드보다 작은 수십 개의 goroutine은 로레벨에서&lt;br /&gt;
5,6개의 스레드를 통해서 실제 구현된 것입니다. Go 언어의 내부에서 goroutine 사이의 메모리 공유를 구현하고 있습니다.&lt;br /&gt;
goroutine을 실행하려면 단지 아주 작은 스택 메모리(대략 4~5KB입니다.)만 필요로 할뿐 입니다. 당연히 이러한 처리로&lt;br /&gt;
해당 데이터가 약간 늘어납니다만, 이런 기능으로 여러 다중 스레드 작업을 수행 할 수 있게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;goroutine은 thread에 비해보다 사용하기 쉽고, 효과적이고 편리 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;goroutine은 Go의 runtime 관리를 이용한 스레드 컨트롤러 입니다.&lt;br /&gt;
goroutine은 &lt;code&gt;go&lt;/code&gt; 키워드에 의해 구현 됩니다. 사실 그냥 일반적인 함수 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go hello(a, b, c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;키워드 go&lt;/code&gt;를 통해 goroutine을 시작 합니다.실제 예를 들어 살펴 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;runtime&amp;quot;
)

func say(s string) {
    for i := 0; i &amp;lt;5; i ++ {
        runtime.Gosched()
        fmt.Println(s)
    }
}

func main() {
    go say(&amp;quot;world&amp;quot;) // Goroutines으로 실행
    say(&amp;quot;hello&amp;quot;)    // 일반 함수로 실행
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 프로그램을 실행하면 다음과 같이 출력됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// hello
// world
// hello
// world
// hello
// world
// hello
// world
// hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go 키워드로 아주 쉽게 멀티 스레드 프로그래밍을 작성할 수 있다는 것을 알 수 있습니다.&lt;br /&gt;
위의 여러개의 goroutine은 동일한 프로세스에서 실행되고 있습니다. 메모리에 데이터를 공유해서 처리하고 있지만&lt;br /&gt;
이러한 메모리 공유를 통해서 통신을 처리하지 말고,  채널을 통해서 데이터를 공유 처리할 것을 권장 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runtime.Gosched()&lt;/code&gt;에서는 CPU 시간을 다른 사람에게 전달 합니다. 다음의 단계에서 계속적으로 이 goroutine을&lt;br /&gt;
실행 합니다. 멀티 코어 프로세서의 멀티 스레드를 실현 하려면 프로그램에서 &lt;code&gt;runtime.GOMAXPROCS(n)&lt;/code&gt; 함수를 호출해서&lt;br /&gt;
호출한 곳에서 동시에 여러 프로세스를 사용하도록 통보해야 합니다. &lt;code&gt;GOMAXPROCS()&lt;/code&gt; 함수는 &lt;code&gt;동시에 실행&lt;/code&gt;하는&lt;br /&gt;
코드 시스템 프로세스의 최대 개수를 설정한 후 이전 설정을 반환 합니다.&lt;br /&gt;
만약 &lt;code&gt;n &amp;lt; 1&lt;/code&gt; 인 경우 현재 설정은 변경되지 않습니다.&lt;/p&gt;

&lt;p&gt;Go의 새로운 버전으로 프로세스 배치가 수정되면, 이것은 삭제 될 것입니다.&lt;br /&gt;
Rob Pike의  멀티 스레드의 개발은 다음 문서에서 자세한 내용을 확인하시기 바랍니다.&lt;br /&gt;
&lt;a href=&#34;http://concur.rspace.googlecode.com/hg/talk/concur.html#landing-slide&#34;&gt;Rob Pike&amp;rsquo;s Multi Thread&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;channels:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;channels&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;goroutine은 동일한 주소 공간에서 실행됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 공유된 메모리에 대한 액세스는 반드시 동기화되어 있어야만 합니다. 문제는 goroutine 사이에서 어떻게 데이터 통신을&lt;br /&gt;
처리 하느냐 문제입니다. Go는 &lt;code&gt;채널&lt;/code&gt;이라는 아주 좋은 통신 메커니즘을 제공 합니다.&lt;br /&gt;
&lt;code&gt;채널은 Unix shell과 양방향 파이프&lt;/code&gt;를 만듭니다. 이를 통해서 값을 보내거나 받을 수 있게 되는 것입니다.&lt;br /&gt;
이 값은 특정 형태만 허용 됩니다. 바로 &lt;code&gt;채널 형&lt;/code&gt;입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;channel을 정의하면 채널에 전송하는 값의 형식도 정의해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주의하시기 바랍니다. &lt;strong&gt;반드시 make()를 사용해 channel을 만듭니다.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ci := make (chan int)
cs := make (chan string)
cf := make (chan interface {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channel은 &lt;code&gt;&amp;lt;-&lt;/code&gt; 연산자를 사용하여 데이터를 보내거나 받거나 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch &amp;lt;- v        // v를 channel ch에 보냅니다. 
v := &amp;lt;-ch      // ch 채널에서 데이터를 받아서 v에 대입 합니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예제에 적용시켜 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func sum(a [] int, c chan int) {
    total := 0
    for _ v := range a {
        total += v
    }
    
    c &amp;lt;- total              // 보내기   
}

func main() {
    a := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int)
    go sum(a[:len(a) / 2], c)
    go sum(a[len(a) / 2:], c)
    x, y := &amp;lt;-c &amp;lt;-c       // 받기 

    fmt.Println (x, y, x + y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;기본적으로 channel이 주고받는 데이터는 차단되어 있습니다. 다른 하나가 준비되어 있지 않으면 Goroutines&lt;br /&gt;
동기화는 더 쉬워집니다. lock을 별도로 표시 할 필요가 없습니다. 이른바 블록은 &lt;code&gt;value := &amp;lt;-ch&lt;/code&gt;에서 채널에서&lt;br /&gt;
데이터를 읽기 전까지는 차단 됩니다. 데이터를 받은 후 &lt;code&gt;ch &amp;lt;-5&lt;/code&gt;로 데이터가 읽힐 때까지 블록 됩니다.&lt;br /&gt;
버퍼링이없는 channel은 여러 goroutine 간의 동기화를 처리하는 아주 훌륭한 도구 입니다.&lt;/p&gt;

&lt;h2 id=&#34;buffered-channels:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;Buffered Channels&lt;/h2&gt;

&lt;p&gt;위에서는 기본적으로 버퍼링이없는 channel을 설명 했습니다. 그러나 Go는 channel 버퍼링을 지정하는 것을 허락&lt;br /&gt;
합니다. 사용 방법은 아주 간단 합니다. 즉 channel에 여러 가지 요소를 저장할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ch := make(chan book 4)&lt;/code&gt;는 4개의 bool 형의 요소를 처리할 channel을 만듭니다. 이 channel에서 4가지&lt;br /&gt;
요소는 블록되지 않고 입력 할 수 있습니다. 다섯 번째 요소가 입력 된 경우 코드는 차단 된후, 다른 goroutine이&lt;br /&gt;
channel에서 요소를 꺼낼 때까지 블럭합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := make(chan type, value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;value == 0 이면 버퍼링 없다는 의미이며 블록 처리 됩니다.&lt;br /&gt;
value &amp;gt; 0 이면, 버퍼링 처리를 의미하며, 버퍼크기를 처리할때 까지는 블록 처리 되지 않습니다.&lt;/p&gt;

&lt;p&gt;아래의 예를 참고 하시기 바랍니다. 로컬에서 테스트 해 볼 수 있습니다.&lt;br /&gt;
대응하는 value 값을 변경해서 사용하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main () {
    c := make(chan int 2)  // 2를 1로 수정하면 오류가 발생 합니다. 
    c &amp;lt;- 1                 // 2를 3으로 수정하면 정상적으로 실행 됩니다.
    c &amp;lt;- 2
    fmt.Println (&amp;lt;- c)
    fmt.Println (&amp;lt;- c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;range와-close:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;Range와 Close&lt;/h2&gt;

&lt;p&gt;위의 예에서는 2번 걸처 c채널에서 값을 가져와야 했습니다. 이런 방식은 그다지 유용하지 않습니다.&lt;br /&gt;
Go는이 이런 점을 고려해서, &lt;code&gt;range&lt;/code&gt; 를 사용해서 slice나 map을 조작했던 것과 같은 방식으로&lt;br /&gt;
 &lt;code&gt;버퍼링 channel&lt;/code&gt;을 처리 할 수 있습니다. 아래의 예를 참고 하시기 바랍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

func fibonacci(n int, c chan int) {
    x, y := 1 1
    for i := 0; i &amp;lt;n; i ++ {
        c &amp;lt;- x
        x, y = y, x + y
    }
    close(c)
}

func main() {
    c := make(chan int 10)
    go fibonacci(cap(c) c)
    for i := range c {
        fmt.Println(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for i : = range c&lt;/code&gt;에서 이 channel이 명시적으로 닫힐때까지 연속족으로 channel의 데이터를 로드&lt;br /&gt;
할 수 있습니다. 위의 코드에서도 channel의 종료가 명시적으로 처리됨을 알 수 있습니다.&lt;br /&gt;
생산자는 &lt;code&gt;close()&lt;/code&gt; 내장 함수에 의해 channel을 닫습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;channel을 닫은 후에는 어떠한 데이터도 보낼 수 없습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;소비자는 &lt;code&gt;v, ok := &amp;lt;-ch&lt;/code&gt;과 같은 방식으로 channel이 이미 닫혀 있는지 여부를 테스트 할 수 있습니다.&lt;br /&gt;
만약 ok 변수에 &lt;code&gt;false&lt;/code&gt;가 반환되면 channel에는 어떤 데이터도 없고, 닫혀 있다는 의미 입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;생산자에서 channel이 닫히는 점에 주의하십시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;소비자에서 처리하지 않습니다. 이것은 panic을 유발하게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;또한 channel은 파일과 같은 자원이 아님에 유의하십시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 파일처럼 자주 닫을 필요가 없습니다. 어떤 데이터도 보낼 수없는 경우 또는 range 루프를 종료시키고 싶은&lt;br /&gt;
경우에만 사용합니다.&lt;/p&gt;

&lt;h2 id=&#34;select:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;Select&lt;/h2&gt;

&lt;p&gt;지금까지는 channel이 한개라는 상황에서 설명했습니다. 만약 여러개의 channel이 사용된다면 어떻게 처리해야 할까요?&lt;br /&gt;
Go는 키워드 &lt;code&gt;select&lt;/code&gt;를 제공해서 여러개의 채널에서 선택문을 처리할 수 있도록 합니다. &lt;code&gt;select&lt;/code&gt;문을 통해서&lt;br /&gt;
channel에 어떤 데이터를 모니터링 할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;select&lt;/code&gt;은 기본적으로 차단 상태로 작동 됩니다. channel에서 교환되는 데이터를 모니터링 할 때만 실행 합니다.&lt;br /&gt;
여러개의 channel이 존재할때, select는 무작위로 하나를 선택한 후 실행 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func fibonacci(c, quit chan int) {
    x, y := 1 1
    for {
        select {
        case c &amp;lt;- x:
            x, y = y, x + y
        case &amp;lt;- quit:
            fmt.Println(&amp;quot;quit&amp;quot;)
            return
        }
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i &amp;lt; 10; i ++ {
            fmt.Println(&amp;lt;- c)
        }
        quit &amp;lt;- 0
    }()
    fibonacci (c, quit)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;select&lt;/code&gt; 문에서도 &lt;code&gt;default&lt;/code&gt;문이 존재합니다. &lt;code&gt;select&lt;/code&gt;은 사실 &lt;code&gt;채널 switch&lt;/code&gt;라고 생각하시면 편합니다.&lt;br /&gt;
&lt;code&gt;select&lt;/code&gt;문에서 default의 의미는 감시하고있는 channel이 모두 준비가되어 있지 않을 때 기본적으로 실행 됩니다.&lt;br /&gt;
(select는 channel을 기다리고 차단하지 않습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
case i := &amp;lt;-c:
     // use i
default :
     // c가 차단 될 때, 이부분이 실행 됩니다.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;시간:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;시간&lt;/h2&gt;

&lt;p&gt;가끔 goroutine이 차단되는 상황에 직면하게 됩니다. 이때 프로그램 전체가 차단되는 상황을 어떻게 피할 수 있을까요?&lt;br /&gt;
&lt;code&gt;select&lt;/code&gt;를 사용해서 시간을 설정 할 수 있습니다. 다음과 같이 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    c := make (chan int)
    o := make (chan bool)
    go func() {
        for {
            select {
            case v := &amp;lt;- c:
                println(v)
            case &amp;lt;- time.After (5 * time.Second):
                println ( &amp;quot;timeout&amp;quot;)
                o &amp;lt;- true
                break
            }
        }
    }()
    &amp;lt;- o
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;runtime-goroutine:88b9e7cb23bd5f0c2257b70a9308e290&#34;&gt;runtime goroutine&lt;/h2&gt;

&lt;p&gt;runtime 패키지는 goroutine을 처리하는 몇 가지 기능이 포함되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Goexit&lt;br /&gt;
이전에 실행 된 goroutine에서 탈출합니다. 그러나 defer() 함수는 계속해서 호출 됩니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Gosched&lt;br /&gt;
이전의 goroutine의 실행 권한을 전달 합니다. 디스패처에서 대기중인 다른 작업의 실행을 계획하고&lt;br /&gt;
다음의 어떤 시점에서 현재  위치로 실행을 복원 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NumCPU&lt;br /&gt;
CPU의 코어 수를 반환 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NumGoroutine&lt;br /&gt;
현재 실행중인 수와 대기 작업의 수를 반환 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GOMAXPROCS&lt;br /&gt;
실행할 수있는 CPU 코어 수의 최대 값을 설정하고 설정된 코어 수를 반환 합니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>